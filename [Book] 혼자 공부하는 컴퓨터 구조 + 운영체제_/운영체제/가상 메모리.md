## 가상 메모리

### 연속 메모리 할당

프로세스가 연속적으로 메모리 내에 배치되는 상황을 연속 메모리 할당 방식이라고 한다.

#### 스와핑

메모리에 적재된 프로세스들 중에서 현재 실행되지 않는 프로세스가 있을 수 있다(대기 상태, 오래동안 사용 x). 이런 프로세스들을 임시로 보조기억장치 일부 영영으로 쫒아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 스와핑이라고 한다.

이때 프로세스들이 쫒겨나는 보조기억장치의 일부 영역을 스왑 영역이라고 한다.

메모리에서 쓰여지지 않는 프로세스가 스왑 영역으로 옮겨지는 것을 스왑 아웃, 반대로 스왑 영역에서 메모리로 옮겨와지는 것을 스왑 인이라고 한다. (스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되지 전의 물리 주소와 다른 주소에 적재될 수 있다.)

스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.

유닉스와 리눅스, macOS에서는 free, top 명령어 등을 통해 스왑 영역의 크기를 확인할 수 있다. 스왑 영역의 크기와 사용 여부는 사용자가 임의로 설정할 수 있다.

#### 메모리 할당

메모리에 빈 공간이 여러 개 있다면 프로세스를 어디에 배치해야 할까?

대표적으로 최초 적합, 최적 적합, 최악 적합이 있다.

최초 적합은 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.

최적 적합은 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방법이다.

최악 적합은 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치한다.

#### 외부 단편화

(external fragmentation)

프로세스가 끝난 자리에 남아 낭비되는 메모리들이 발생하는 현상.

외부 단편화를 해결할 수 있는 대표적인 방안으로 압축(compaction)이 있다. 메모리 조각 모음이라고도 부른다. 압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법이다.

단점으로는 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기한다는 것이 있다. 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 방법도 결정하기 힘들다.

### 페이징을 통한 가상 메모리 관리

페이징은 현대 운영체제 메모리 관리 기법에 있어 가장 중요한 개념이라고 해도 과언이 아닐 만큼 중요하다.

프로세스를 연속적으로 메모리에 할당하는 방식은 두 가지 문제를 내포하고 있다. 첫째는 외부 단편화고 둘째는 물리 메모리보다 큰 프로세스를 실행할 수 없다는 것이다.

가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다. 이를 구현하는 방법에는 페이징과 세그멘테이션이 있지만, 현대 대부분의 운영체제에서는 페이징을 사용한다. 페이징을 사용하면 외부 단편화 문제도 해결할 수 있다.

프로세스를 일정한 단위로 잘라서 불연속적으로 메모리에 할당하는 것을 페이징이라 한다.

이때 물리 주소 공간을 프레임이라는 단위로 자르고 논리 주소 공간은 페이지 단위로 자른다.

프로세스 전체가 스왑 아웃, 스왑 인되는 것이 아니라 페이지가 그렇게 되는 것을 페이지 아웃, 페이지 인이라고 부른다.

#### 페이지 테이블

프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문이다. 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에서는 연속적으로 배치되도록 페이지 테이블을 이용한다.

페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.

페이징은 내부 단편화라는 문제를 야기할 수 있다.
모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다. 페이지가 크기가 남아서 물리 주소에 낭비되는 메모리가 존재하게 된다. 이를 내부 단편화라고 한다. 그렇다고 페이지 크기를 작게하면 페이지 테이블의 크기가 커져 공간이 낭비된다. 따라서 적절한 페이지의 크기를 만드는 것이 중요하다.

프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다. 그리고 CPU 내의 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.

각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록된다.

페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다. (페이지 테이블을 보기 위해 한 번, 알게 된 프페임에 접근하기 위해 한 번)

이 문제를 해결하기 위해 CPU 곁에 (일반적으로 MMU 내에) TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 둔다.

CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB 히트라고 한다.

#### 페이징에서의 주소 변환

하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있다. 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요하다.

- 어떤 페이지 혹은 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

그렇기에 페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호와 변위(offset)로 이루어져 있다.

#### 페이지 테이블 엔트리

페이지 테이블의 각각의 행들을 페이지 테이블 엔트리라고 한다.
페이지 테이블 엔트리에는 여러 중요한 정보들이 있다. 대표적인 것으로 유효 비트, 보호 비트, 참조 비트, 수정 비트가 있다.

##### 유효 비트

현재 해당 페이지에 접근 가능한지 여부를 알려준다. 프레임 번호 다음으로 중요한 정보라고도 볼 수 있다. 유효비트는 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려주는 비트다. 만일 CPU가 유효 비트가 0 (보조기억장치에 있는)에 접근하려고 하면 페이지 폴트라는 예외가 발생한다. (CPU가 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사하다.)

##### 보호 비트

보호 비트는 페이지 보호 기능을 위해 존재하는 비트다. 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다. 보호 비트는 r,w,x 3 종류로 쪼갤 수도 있다.

##### 참조 비트

CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다. 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지는 0으로 유지된다.

##### 수정 비트

수정 비트는 해당 페이지에 데이터를 쓴 적이 있는지 그 수정 여부를 알려준다. 더티 비트라고 부르기도 한다.

수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지 판단하기 위해 존재한다.
(만약 수정이 되었으면 보조기억장치에도 수정된 것을 저장해야 하기 때문이다. 수정이 안되었으면 보조기억장치에 있는 것과 메모리에 있는 파일은 똑같기 때문에 추가 작업을 하지 않아도 된다.)

##### 쓰기 시 복사

페이징의 이점 중 하나는 프로세스 간에 페이지를 공유할 수 있다는 점이다. 공유할 수 있는 방법의 대표적인 예시로 쓰기 시 복사가 있다.

리눅스와 같은 운영체제에서 fork 시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세스로서 만들어진다. 프로세스 간에는 기본적으로 자원을 공유하지 않기 때문에 새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 전혀 다른 메모리 공간에 생성된다. 즉, 복제가 된다. 하지만 이 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기한다.

쓰기 시 복사에서는 자식 프로세스가 생성되면 부모 프로세스와 동일한 프레임을 가리킨다. 읽기만 하는 경우 아무 일도 일어나지 않다가 쓰기 작업이 시작되면 그때서야 별도에 공간에 저장이 되는 원리다. 이를 통해 프로세스 생성 시간과 메모리 공간을 절약할 수 있다.

##### 계층적 페이징

프로세스의 크기가 커지면 페이지 테이블의 크기도 커진다. 따라서 프로세스를 구성하는 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비다. 계층적 페이징은 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않는 방법이다.

계층적 페이징은 페이지 테이블을 페이징한다. 계층적 페이징의 경우 바깥 페이지 번호와 안쪽 페이지 번호, 변위로 구성된다. 페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아진다. 따라서 반드시 좋다고는 볼 수 없다.

#### 페이지 교체와 프레임 할당

##### 요구 페이징

프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법을 요구 페이징이라고 한다.

1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
2. 해당 페이지가 현재 메모리에 있을 경우 CPU는 페이지가 적재된 프레임에 접근한다.
3. 해당 페이지가 현재 메모리에 없을 경우 페이지 폴트가 발생한다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 다시 1번을 수행한다.

아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행해서 폴트로 시작하는 것을 순수 요구 페이징 기법이라고 한다.

요구 페이징 시스템이 안정적으로 작동하려면 페이지 교체와 프레임 할당이 해결되어야 한다.

요구 페이징 기법으로 페이지들을 적재하다가 메모리가 가득 차게 되면 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다. 이때, 내보낼 페이지를 결정하는 방법을 페이지 교체 알고리즘이라고 한다.

##### 페이지 교체 알고리즘

페이지 폴트를 가장 적게 일으키는 알고리즘을 일반적으로 좋은 것으로 평가한다. 그렇기에 교체 알고리즘을 제대로 이해하려면 페이지 폴트 횟수를 알 수 있어야 한다. 페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있다. 페이지 참조열은 CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미한다.

###### FIFO 페이지 교체 알고리즘

메모리에 가장 먼저 올라온 페이지부터 내쫒는 방식이다. 이는 메모리에 먼저 적재되었지만 계속 사용되는 프로세스를 갖고 있는 경우 좋은 방식은 아니다.

###### 2회 기회 페이지 교체 알고리즘

FIFO의 변형이며 CPU의 접근을 1회 봐준다.

###### 최적 페이지 교체 알고리즘

CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다.
사용 빈도에 따라 결정한다. 가장 폴트 발생 확률이 낮지만 구현이 어렵다.

###### LRU(Least Recently Used) 페이지 교체 알고리즘

가장 오랫동안 사용되지 않은 페이지를 교체한다.

##### 스래싱과 프레임 할당

프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생한다.

프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저하되는 문제를 스래싱이라고 한다.

프레임 할당 방식

균등 할당?
모든 프로세스에 균등하게 프레임을 제공하는 방식이다. 이를 균등 할당이라고 한다.

비례 할당?
프로세스의 크기가 크면 프레임을 많이 할당하고 작으면 적게 나눠준다.

균등 할당과 비례 할당 방식은 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려한 방식이라는 점에서 정적 할당 방식이라고도 한다.

프로세스의 크기가 항상 프레임 크기와 비례하지는 않는다. 결국 실행해 봐야 아는 경우가 많다.

프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식에는 크케 작업 집합 모델(working set model)을 사용하는 방식과 페이지 폴트 빈도(Page-Fault Frequency)를 사용하는 방식이 있다. (프로세스 실행을 보고 할당할 프레임 수를 결정한다는 점에서 동적 할당 방식이라고도 한다.)

스래싱의 발생 이유는 빈번한 페이지 교체 때문이다. 그렇기에 작업 집합 모델 기반 프레임 할당 방식은 '프로세스가 일정 기간 동안 참조한 페이지 집합'을 기억하여 빈번한 페이지 교체를 방지한다. (참조 지역성의 원리)

실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 작업 집합(working set)이라고 한다.

페이지 폴트 빈도를 기반으로 한 프레임 할당을 보자.

1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다. (조각이 큼지막해서 보조기억장치에 있는 녀석이 걸릴 확률이 높다.)

2. 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다. (너무 조각조각 작은 부분이라서 어지간해서는 필요하다는 것)

따라서 적당한 프레임 수가 할당되게끔 상항선과 하한선 내에서 프레임 수를 조절하는 것을 페이지 폴트 빈도 기반이라고 한다.
