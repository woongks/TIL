### CPU 클럭

CPU는 클럭을 기준으로 움직인다.

클럭은 clock이기 때문에 시계처럼 일정한 속도로 클럭 속도가 유지된다고 생각할 수 있다.
하지만 실제로는 일정하지 않고, base 속도와 max 속도 사이를 왔다갔다 한다.
이는 작업이 어떤 성능을 요구하는지에 따라 맞춰진다.

클럭 속도가 높으면 좋은 성능을 내지만, 무작정 높이면 발열 문제가 심각해지게 된다.
따라서 클럭 속도로 CPU의 성능을 높이는 데엔 한계가 있다.

### 코어와 멀티코어

코어는 명령어를 실행하는 부품으로 생각할 수 있다. 전에는 하나의 CPU의 하나의 코어만 존재하는 것이 정석이었지만, 오늘날에는 듀얼코어, 쿼드코어 등 여러 코어를 가진 CPU가 정석이다. 코어의 개수가 많을수록 명령어를 실행할 수 있는 일꾼이 더 많아지는 것이기 때문에 성능이 더 좋아질 수 밖에 없다. 물론 코어의 개수에 비례해서 연산 처리 속도가 증가하는 것은 아니다.

### 스레드와 멀티스레드

스레드는 실행 흐름의 단위다. 여기서 주의해야 할 점은 CPU에서 사용되는 스레드와 프로그래밍에서 사용되는 스레드는 다르다는 사실이다. 스레드는 CPU에 사용되는 하드웨어적 스레드가 있고, 프로그램에서 사용되는 소프트웨어적 스레드가 있다.

하드웨어적 스레드는 하나의 코어가 동시에 처리하는 명령어 단위를 의미한다.
하나의 코어로 여러 명령어를 동시에 처리하는 CPU는 멀티스레드 프로세서 또는 멀티스레드 CPU라고 불린다.

- 인텔의 멀티스레드 기술을 하이퍼스레딩이라고 한다.

소프트웨어적 스레드는 하나의 프로그램에서 독립적으로 실행되는 단위를 뜻한다.

1코어 1스레드 CPU로 수십 개의 소프트웨어적 스레드를 실행할 수 있다.

멀티스레드 프로세서는 설계하기가 힘들다. 가장 큰 핵심은 레지스터다. 레지스터 묶음을 여러 개 가지고 있으면 된다.

하드웨어 스레드는 논리 프로세서라고 부르기도 한다. 프로그램이 보기에 1코어 2스레드는 결국 2개의 명령어 실행기이기 때문이다.

### 명령어 병렬 처리 기법

명령어 병렬 처리 기법 (ILP: Instruction-Level Parallelism)

대표적인 명령어 처리 기법으로는 명령어 **파이프라이닝**, **슈퍼스칼라**, **비순차적 명령어 처리**가 있다.

명령어 처리 과정을 클럭 단위로 나누어 보면 다음과 같이 나눌 수 있다.

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

이 과정은 겹치지만 않으면 동시에 실행할 수 있다. 이 방법을 통해 명령어들을 동시에 처리하는 기법을 파이프라이닝이라고 한다.

이 기법이 항상 성능 향상을 가져오지는 않는다. 실패하는 경우를 파이프라인 위험이라고 부른다. 크게 3 가지가 있다.

1. 데이터 위험
2. 제어 위험
3. 구조적 위험

#### 데이터 위험

이전 명령어를 끝까지 수행해야만 다음 명령어를 실행할 수 있는 경우. (즉, 무작정 두 명령어를 동시에 실행하려고 하면 제대로 작동하지 않을 것이다.)

#### 제어 위험

프로그램 카운터의 갑작스러운 변화에 의해 발생. 기본적으로 프로그램 카운터는 현재 실행 중인 명령어의 다음 주소로 갱신이 되는데 실행 단계에서 프로그램 카운터의 값이 바뀌면 아직 실행 단계에 다다르지 않은 다른 명령어들에게 영향을 미치게 된다. 이를 예방하기 위해 **분기 예측** 기술이 사용된다.

#### 구조적 위험

명령어들을 겹쳐 실행하는 과정에서 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생한다. **자원 위험**이라고 부르기도 한다.

</ br>

CPU 내부에 여러 파이프라인을 이용한 것을 **슈퍼스칼라**라고 한다.

파이프라인에서 생길 수 있는 단점이 더 부각되기 때문에 설계를 잘해야 한다.

</ br>
비순차적 명령어 처리 (OoOE: Out-of-Order Execution)

오늘날 대부분 CPU가 차용하는 기법이다. 명령어들을 순차적으로 실행하지 않는다.

### CISC와 RISC

CPU를 만드는 회사는 많다. 따라서 CPU마다 차이가 조금씩 존재한다. 명령어의 생김새, 주소 지정 방식 등 세세한 부분에서 차이가 존재한다. CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합 또는 명령어 집합 구조 (ISA: Instruction Set Architecture)라고 한다.
즉 CPU마다 다른 ISA가 있다.

ISA는 크게 CISC와 RISC로 분류된다.

CISC는 Complex Instruction Set Computer의 약자다. 이를 그대로 해석하면 '복잡한 명령어 집합을 활용하는 컴퓨터'를 의미한다. x86, x86-64는 대표적인 CISC기반의 ISA다.

CISC는 복잡하고 다양한 수의 가변 길이 명령어 집합을 활용한다.
이는 적은 수의 명령어로도 프로그램을 실행할 수 있다는 것을 의미한다.
따라서 CISC는 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았다.
하지만 복잡하고 다양한 기능을 제공하는 만큼 명령어의 크기와 실행되기까지의 시간이 일정하지 않다. 그리고 하나의 명령어를 실행하는 데에 여러 클럭 주기를 필요로 한다.
즉, 파이프라이닝을 구현하는 것이 어렵다.

RISC (Reduced Instruction Set Computer)는 CISC에 비해 명령어의 종류가 적다. 짧고 규격화된 명령어를 지향한다. RISC는 고정 길이 명령어를 활용한다. 따라서 파이프라이닝에 최적화되어 있다.

RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한한다. 따라서 load-store 구조라고 부르기도 한다.
