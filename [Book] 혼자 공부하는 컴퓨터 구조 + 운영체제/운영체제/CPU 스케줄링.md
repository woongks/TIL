### CPU 스케줄링

프로세스마다 필요로 하는 자원은 각기 다르지만, CPU는 모든 프로세스가 필요로 한다. 운영체제가 CPU를 프로세스에 나누어주는 방법을 스케줄링이라 한다.

CPU 스케줄링은 컴퓨터의 성능과 직결되는 중요한 문제다.

프로세스들에게 CPU를 공정하게 배분하는 방법은 차례로 돌아가며 먼저 요청한 프로세스 순서대로 CPU를 이용하게 하는 방법이 합리적인 것 같지만 좋은 방법은 아니다. 프로세스마다 우선순위가 다르기 때문이다.

우선순위가 높은 프로세스는 빨리 처리해야 한다. 대표적으로 입출력 작업이 많은 프로세스가 있다.

프로세스에는 입출력 집중 프로세스가 있고 CPU 집중 프로세스가 있다. 입출력 집중 프로세스는 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무르고 CPU 집중 프로세스는 대기 상태보다 실행 상태에 더 많이 머무른다.

CPU를 이용하는 작업을 CPU 버스트, 입출력장치를 기다리는 작업을 입출력 버스트라 부른다. 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행된다.

CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 자원을 요구하면 입출력 집중 프로세스를 가능한 끊임없이 작동시키고 그 다음 CPU 집중 프로세스에 CPU를 할당하는 것이 효율적이다. 입출력 작업을 완료하기 전까지 입출력 집중 프로세스는 대기 상태가 될 예정이기 때문에 얼른 먼저 처리해버리면 다른 프로세스가 CPU를 사용할 수 있기 때문이다.

운영체제는 각 프로세스의 PCB에 우선순위를 명시하고 PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

매번 CPU가 모든 PCB를 검사하여 우선순위를 확인하고 먼저 자원을 이용할 프로세스를 결정하는 일은 매우 번거로울뿐더러 오랜 시간이 걸리는 일이다.

그래서 운영체제는 프로세스들에 줄을 서서 기다릴 것을 요구하는데 이를 스케줄링 큐로 구현한다. (스케줄링 큐는 반드시 FIFO가 아니다.)

운영체제는 메모리로 적재되고 싶은 프로세스들, CPU를 이용하고 싶은 프로세스들, 그리고 특정 입출력장치를 이용하고 싶은 프로세스들을 각각 큐에 삽입하여 줄을 세운다.

대표적인 큐로는 준비 큐와 대기 큐가 있다. 준비 큐는 CPU를 이용하고 싶은 프로세스들이 서는 줄, 대기 큐는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미한다.

이렇게 운영체제는 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내서 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행한다.

#### 선점형과 비선점형 스케줄링

갑자기 다른 급한 프로세스가 CPU를 지금 당장 사용하길 요청한다면 어떡해야 할까?

지금 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에게 할당할 수도 있고, CPU를 사용 중인 프로세스의 작업이 끝날 때까지 다른 급한 프로세스를 기다리게 할 수도 있다. 이 방법을 각각 선점형 스케줄링과 비선점형 스케줄링이라고 한다.

선점형 스케줄링(preemptive scheduling)은 프로세스가 자원을 사용하고 있더라도 강제로 자원을 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식을 의미한다.

비선점형은 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 의미한다.

#### CPU 스케줄링 알고리즘

CPU 스케줄링 알고리즘의 종류는 매우 다양하고 운영체제 저마다 서로 다른 스케줄링 알고리즘을 사용하고 있다.

##### 선입 선처리 스케줄링

선입 선처리 스케줄링은 FCFS 스케줄링 (First Come First Served Scheduling) 이라고 부른다. 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다.
이럴 경우 짧은 시간 사용을 위해 긴 시간을 기다려야 할 수도 있는데, 이를 호위 효과(convoy effect)라고 한다.

##### 최단 작업 우선 스케줄링

큐에 있는 것들 중 사용 시간이 가장 짧은 것부터 실행한다. SJF (Shortest Job First) 스케줄링이라고도 한다. 최단 작업 우선 스케줄링은 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수도 있다.

##### 라운드 로빈 스케줄링

선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식이다. 즉, 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링이다. 라운드 로빈 스케줄링에서는 타임 슬라이스의 크기가 매우 중요하다. 타임 슬라이스 크기가 너무 크면 일반 선입 선처리 스케줄링과 차이가 없을 수 있고 크기가 너무 작으면 프로세스 전환을 그만큼 자주해 비효율적이기 때문이다.

##### 최소 잔여 시간 우선 스케줄링

최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식이다. 최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용한다. CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.

##### 우선순위 스케줄링

프로세스들에 우선순위를 부여하고 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다. 우선순위가 낮은 프로세스는 계속 밀리는 단점이 있다. 이를 기아(starvation) 현상이라고 한다. 이를 방지하기 위한 대표적인 기법으로 에이징(aging)이 있다. 이는 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다.

##### 다단계 큐 스케줄링

우선순위 스케줄링의 발전된 형태다. 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다. 다단계 큐 스케줄링 하에서는 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리한다. 큐마다 다른 타임 슬라이스를 지정할 수도 있고 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있다.

##### 다단계 피드백 큐 스케줄링

다단계 큐 스케줄링의 발전된 형태다. 프로세스들이 큐 사이를 이동할 수 없으면 우선순위가 낮은 프로세스는 계속 연기될 수 있다. 이를 보완하기 위해 큐 사이 이동을 가능하게 했다. 다단계 피드백 큐 스케줄링은 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 큐에 삽입되고 타임 슬라이스만큼 실행된다. 만약 프로세스 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다. 그리고 또 끝나지 않는다면 프로세스는 또 다음 낮은 우선순위 큐에 삽입된다. CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝난다.
또 에이징 기법을 적용해서 너무 낮은 곳에서 오래 기다리는 프로세스를 끌어올릴 수도 있다.
