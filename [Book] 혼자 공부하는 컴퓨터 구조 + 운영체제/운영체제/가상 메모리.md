## 가상 메모리

### 연속 메모리 할당

프로세스가 연속적으로 메모리 내에 배치되는 상황을 연속 메모리 할당 방식이라고 한다.

#### 스와핑

메모리에 적재된 프로세스들 중에서 현재 실행되지 않는 프로세스가 있을 수 있다(대기 상태, 오래동안 사용 x). 이런 프로세스들을 임시로 보조기억장치 일부 영영으로 쫒아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 스와핑이라고 한다.

이때 프로세스들이 쫒겨나는 보조기억장치의 일부 영역을 스왑 영역이라고 한다.

메모리에서 쓰여지지 않는 프로세스가 스왑 영역으로 옮겨지는 것을 스왑 아웃, 반대로 스왑 영역에서 메모리로 옮겨와지는 것을 스왑 인이라고 한다. (스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되지 전의 물리 주소와 다른 주소에 적재될 수 있다.)

스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.

유닉스와 리눅스, macOS에서는 free, top 명령어 등을 통해 스왑 영역의 크기를 확인할 수 있다. 스왑 영역의 크기와 사용 여부는 사용자가 임의로 설정할 수 있다.

#### 메모리 할당

메모리에 빈 공간이 여러 개 있다면 프로세스를 어디에 배치해야 할까?

대표적으로 최초 적합, 최적 적합, 최악 적합이 있다.

최초 적합은 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.

최적 적합은 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방법이다.

최악 적합은 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치한다.

#### 외부 단편화

(external fragmentation)

프로세스가 끝난 자리에 남아 낭비되는 메모리들이 발생하는 현상.

외부 단편화를 해결할 수 있는 대표적인 방안으로 압축(compaction)이 있다. 메모리 조각 모음이라고도 부른다. 압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법이다.

단점으로는 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기한다는 것이 있다. 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 방법도 결정하기 힘들다.

### 페이징을 통한 가상 메모리 관리

페이징은 현대 운영체제 메모리 관리 기법에 있어 가장 중요한 개념이라고 해도 과언이 아닐 만큼 중요하다.

프로세스를 연속적으로 메모리에 할당하는 방식은 두 가지 문제를 내포하고 있다. 첫째는 외부 단편화고 둘째는 물리 메모리보다 큰 프로세스를 실행할 수 없다는 것이다.

가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다. 이를 구현하는 방법에는 페이징과 세그멘테이션이 있지만, 현대 대부분의 운영체제에서는 페이징을 사용한다. 페이징을 사용하면 외부 단편화 문제도 해결할 수 있다.

프로세스를 일정한 단위로 잘라서 불연속적으로 메모리에 할당하는 것을 페이징이라 한다.

이때 물리 주소 공간을 프레임이라는 단위로 자르고 논리 주소 공간은 페이지 단위로 자른다.

프로세스 전체가 스왑 아웃, 스왑 인되는 것이 아니라 페이지가 그렇게 되는 것을 페이지 아웃, 페이지 인이라고 부른다.

#### 페이지 테이블

프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문이다. 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에서는 연속적으로 배치되도록 페이지 테이블을 이용한다.

페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.

페이징은 내부 단편화라는 문제를 야기할 수 있다.
모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다. 페이지가 크기가 남아서 물리 주소에 낭비되는 메모리가 존재하게 된다. 이를 내부 단편화라고 한다. 그렇다고 페이지 크기를 작게하면 페이지 테이블의 크기가 커져 공간이 낭비된다. 따라서 적절한 페이지의 크기를 만드는 것이 중요하다.

프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다. 그리고 CPU 내의 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.

각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록된다.

페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다. (페이지 테이블을 보기 위해 한 번, 알게 된 프페임에 접근하기 위해 한 번)

이 문제를 해결하기 위해 CPU 곁에 (일반적으로 MMU 내에) TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 둔다.

CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB 히트라고 한다.

#### 페이징에서의 주소 변환

하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있다. 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요하다.

- 어떤 페이지 혹은 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

그렇기에 페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호와 변위(offset)로 이루어져 있다.
