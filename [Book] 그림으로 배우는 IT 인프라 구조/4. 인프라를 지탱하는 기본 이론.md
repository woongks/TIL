## 인프라를 지탱하는 기본 이론

### 직렬/병렬

CPU라는 미시적인 관점에서 시스템 전체라는 거시적인 관점으로 눈을 돌리면, 대규모 웹 서비스에서는 방대한 수의 사용자 요청을 처리해야 하므로 수많은 서버를 배치해서 병렬로 처리하고 있음을 알 수 있다.

물론 병렬화한다고 성능이 무조건 상향되는 것은 아니다.
예를 들어, CPU 코어나 서버를 병렬화할 때는 병렬화한 하드웨어를 놀리지 않고 어떻게 효율적으로 활용할지가 중요해진다. 

CPU나 HDD 등의 하드웨어 성능은 한계가 있기 때문에, 구조적으로 배치를 하여 성능을 높일 필요가 있다. 속도가 빨라지는 것은 아니지만 동시에 처리할 수 있는 양이 많아지는 것이다.
즉, CPU를 여러 대 두어 병렬화를 하면 고속도로 차선을 늘리는 것처럼 성능의 개선을 기대할 수 있다.

다만 차선을 늘리면 합류 구간에서 병목이 발생하는 것처럼 CPU도 병렬화 후에 일을 다시 한 곳으로 모으면 오버헤드가 발생할 수 있다. 따라서 그 부분을 예상하면서 병렬화하는 것이 중요하다.

#### 웹 서버와 AP 서버에서의 병렬화

웹 서버는 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리를 하고 있다.
AP서버에서는 JVM 프로세스가 하나이지만 복수의 스레드가 병렬로 처리하고 있다.

Apache HTTP Server에서는 멀티 프로세스 모델 외에도 멀티 프로세스와 멀티 스레드를 모두 이용하는 하이브리드형도 있다. JVM 프로세스를 복수 가동하면 멀티 프로세스와 멀티 스레드를 이용할 수 있다.

1프로세스 4스레드여도 CPU 코어가 하나 밖에 없으면 1스레드만 동시 사용 가능하다. 프로세스나 스레드 수를 조정할 때는 CPU 코어 수도 함께 고려해야 한다.
편의점 계산대가 하나밖에 없다면 계산대를 담당하는 사람이 여러 명이라도 소용 없는 것과 마찬가지다.

#### DB 서버에서의 병렬화

DB 서버에서도 프로세스를 늘려서 병렬 처리를 할 수 있다. 클라이언트 요청을 처리하는 서버 프로세스는 복수의 프로세스로 병렬화되어 있다. 디스크에 쓰기 처리를 하는 DBWR 프로세스는 프로세스를 늘려서 병렬로 I/O를 실시할 수 있다.

오라클 DB에서는 클라이언트 요청을 접수하는 서버 프로세스가 클라이언트 접속 수만큼 생성된다. 예를 들어, 클라이언트가 10 접속을 하면 서버 프로세스 수도 10개가 된다. 서버 프로세스에는 멀티 프로세스 모델 외에도 공유 서버형이라 불리는 하이브리드형이 있다. 이 경우 멀티 프로세스와 멀티 스레드를 모두 사용할 수 있는 것도 있다.
데이터 파일 생성 시에 병목 현상이 발생하는 경우, 메모리에 캐시된 갱신 완료 데이터를 HDD에 기록하는 DBWR(DataBase WriteR) 프로세스 수를 늘려서 병렬화할 수도 있다. DBWR 프로세스는 프로세스 수를 늘리는 방법 외에도 비동기 I/O를 사용해서 OS 측에서의 쓰기 처리를 병렬화하는 방법도 있다.

직렬/병렬의 장단점

직렬
> 장점: 구조가 간단해서 설계나 구현 난이도가 낮다.
단점: 복수의 리소스를 유용하게 이용할 수 없다.

병렬
> 장점: 복수의 리소스를 유용하게 이용 가능하며, 직렬에 비해 동일 시간당 처리량이 증가한다. 일부가 고장 나더라도 처리를 계속할 수 있다.
단점: 처리 분기나 합류를 위한 오버헤드가 발생한다. 배타적 제어 등을 고려해야 하고 구조가 복잡해서 설계나 구현 난이도가 높다.

병렬화 주의점:
- 병렬화에서는 직렬 처리 성능은 향상되지 않지만, 단위 시간당 처리량을 늘릴 수 있다.
- 병렬 처리에서는 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다.
- 병렬화가 유효한 부분을 파악해서 병렬화하지 않으면 효과가 없다. 오버헤드나 구조 복잡화 등의 단점이 있다는 것을 고려한 후, 이 단점 이상의 효과를 얻을 수 있는 경우에 병렬화한다.

병렬화 장점으로 처리 능력 향상을 들었지만, 이중화라는 관점에서도 장점이 있다. 리눅스에는 복수의 NIC를 하나로 묶어서 사용하는 본딩이라는 기능이 있다. 이것을 이용하면 NIC가 고장 나도 처리를 계속할 수 있다.

병렬과 병행

동시에 복수의 처리를 실행하는 것이 병렬이고, 복수의 처리가 실행 상태에 있는 것을 병행이라고 한다. 즉, 병행은 병렬을 내포하고 있는 개념이다. 쉽게 말하면, 한 명이 여러 일을 동시에 하는 것은 병행이지만 병렬은 아니다. 여러 사람이 동시에 여러 일을 하는 것은 병렬이다. 

### 동기/비동기

대량의 데이터를 처리하는 대규모 웹 서비스가 늘어나면서 장비 발열과 소비 전력이 문제가 되고 있다. 이런 이유로 매니 코어(Many Core)화가 진행되고 있는 흐름을 보면 앞으로 비동기 병렬 처리를 해야 하는 경우가 더 늘어날 것으로 예상된다.

동기와 비동기의 특징
- 동기는 다른 사람에게 일을 부탁한 후 끝날 때까지 아무것도 하지 않고 기다리기 때문에 그 사이에 다른 것을 할 수 없다. 하지만 의뢰한 것이 끝났는지 여부를 확실하게 알 수 있다.
- 비동기는 끝날 때까지 기다리지 않기 때문에 병렬로 다른 일을 할 수 있다. 하지만 일이 끝났는지 여부를 확인하고 싶으면 별도의 방법을 이용해야 한다.

#### DBMS에서 사용되는 비동기 I/O

DBMS는 HDD 등의 저장소에 비동기로 쓰기 처리를 할 수 있다. 이것을 비동기 I/O라고 한다.
비동기 I/O는 대량의 I/O를 효율적으로 처리해야 하는 DBMS에 적합하다고 할 수 있다.

일반적으로 DBMS엔 I/O를 전문으로 하는 프로세스가 있다
I/O 병렬화에는 프로세스나 스레드를 복수 사용하는 방식과 비동기 I/O 방식이 있다.

동기 I/O로 I/O를 병렬화 하는 경우 DBMS 프로세스를 늘리면 된다.
비동기 I/O는 요구 후 기다리지 않고 다음 I/O를 요구해서 병렬화하고 있다.

비동기로 DBMS 처리를 하는 게 위험하지 않은가?
(쓰기가 끝났는지 확인하지 않고 다음 처리를 진행하기 때문이다.)
> DBMS에서는 비동기로 I/O를 요구한 후에 I/O가 끝났는지 여부를 확인한다. 물론 그렇지 않는 것도 있다.

일반적으로 비동기 I/O는 OS의 라이브러리나 시스템 콜을 사용해서 구현되기 때문에 OS마다 방식이 다르다. 또한, DBMS에서 비동기 I/O를 사용할지 여부는 보통 DBMS측에서 설정할 수 있어서 해당 설정에 따라 OS 라이브러리나 시스템 콜에 전달하는 옵션이 달라진다.

동기/비동기의 장단점

동기
> 장점: 의뢰한 처리가 끝났는지 여부를 쉽게 확인할 수 있어서 구조가 간단하고 구현 난이도도 낮다.

> 단점: 의뢰한 처리가 끝나기까지 기다려야 하기 때문에 대기 시간을 활용할 수 없다.

비동기
> 장점: 의뢰한 처리가 진행되고 있는 동안 시간을 효율적으로 사용해서 병렬 처리를 할 수 있다.

> 단점: 의뢰한 처리가 끝났는지 확인하지 않으면 모르기 때문에 불필요한 확인 처리가 늘어난다. 구조가 복잡해서 구현 난이도가 높다.

c10k 문제?
> 하드웨어 성능상에 문제가 없어도 클라이언트 수가 많아지면 서버가 고장 나는 문제다. 클라이언트 접속마다 프로세스를 생성하면 OS 파일 디스크립터나 프로세스 수가 최대치에 이르거나, 1 프로세스당 소비 메모리 크기는 작지만 이것이 쌓여서 문제가 될 수 있다. 콘텍스트 스위치 등에 사용되는 CPU 사용률도 무시할 수 없다. 그리고 프로세스 수가 너무 많으면 프로세스를 관리하는 OS 커널 내의 관리용 데이터 크기도 커진다.

> c10k 문제를 해결하는 방법으로, 하나의 프로세스로 복수의 접속을 처리하는 방법이 있다. 이때 클라이언트 통신은 정말로 필요한 경우에만 처리한다. 이런 기법은 논블로킹 I/O라고 한다. 논블로킹 I/O는 OS 시스템 콜로 구현돼 있어서, 그것을 그대로 사용한다. 주의점은 모든 접속을 완전히 동기로 처리할 수 없기 때문에 동기 처리 수를 고려해야 한다는 것이다. 특정 처리가 장기화되거나 지연되면 다른 접속에 영향을 줄 수도 있다.

#### 큐

큐는 FIFO(First In First Out) 구조다.

큐가 사용되는 곳
- CPU 처리를 기다리고 있는 프로세스나 스레드 행렬
- 하드 디스크 등의 저장소 읽기 처리를 기다리고 있는 I/O 요구 행렬
- 네트워크 접속 성립을 기다리고 있는 접속 요구 행렬

CPU를 기다리고 있는 프로세스 행렬을 런큐라고 한다.
런큐에 쌓인 프로세스 수를 코어 수로 나누어서 1이라면 문제 없다는 것이 일반적이다. CPU에서 처리 중인 프로세스를 런큐로 인식할지는 OS 종류에 따라 달라진다. 리눅스에서는 CPU에서 실행 중인 프로세스도 런큐로 인식한다. OS 커널에는 프로세스 스케줄러라는 기능이 있어서 런큐 등을 관리한다.

#### 데이터베이스의 디스크 I/O

DB의 디스크 I/O의 기본적인 개념은 CPU와 같다.
프로세스나 스레드가 사용하는 대상이 CPU가 아닌 HDD인 점만 다르다.

HDD의 특정 위치에 접근해야 하기 때문에 CPU처럼 비어 있다는 이유로 다른 위치를 사용할 수 없다.
또한, 캐시를 내장하고 있는 경우 I/O가 발생할 때 캐시에서 데이터를 가져다 쓸 수도 있다. 이런 방식의 설계는 성능 고속화로 연결된다.

### 배타적 제어

여러 사람이 공유하는 것은 배타적 제어가 필요하다.
컴퓨터 처리에서도 직렬 처리는 배타적 제어가 필요 없지만, 병렬 처리에서는 필요하다. 배타적 제어를 하는 부분은 병목 현상이 발생하기 쉽다. 병렬 처리와 배타적 제어를 머릿속에 그릴 수 있게 되면 문제 해결이나 성능 튜닝에 도움이 된다.

일반적으로 OS나 DBMS는 병렬 처리를 위해 배타적 제어를 사용한다. 공유 데이터를 이용하는 경우 부분적으로 직렬 처리가 필요한데, 이때 배타적 제어를 한다.

배타적 제어의 특징은 다음과 같다:
- 복수의 처리가 공유 자원(CPU,메모리,디스크 등)에 동시에 액세스(주로 갱신)하면 불일치가 발생할 수 있기 때문에 배타적 제어로 보호해 주어야 한다.
- 배타적 제어에서는 특정 처리가 공유 자원을 이용하고 있는 동안 다른 처리가 이용할 수 없게 해서 불일치가 발생하지 않도록 한다.

#### DBMS에 사용되는 배타적 제어

오라클DB에서는 여러 프로세스가 동시에 병행으로 처리를 하고 있지만, 특정 프로세스가 공유 데이터를 변경하고 있는 도중에 다른 프로세스가 해당 공유 데이터를 읽거나 공유 데이터를 동시에 변경하지 못하도록 배타적 제어를 하고 있다.

DBMS의 배타적 제어에서는 매우 짧은 시간 동안만 락(lock)을 유지하는 래치(latch)라는 것이 있어서 CPU에서 의미가 없는 처리를 하면서 대기하는 방식이 있다. 스핀락이라고도 불린다. 한편, 비교적 장시간 락을 유지하도록 큐를 이용해서 관리하는 방식인 슬립락(sleep-lock)이라는 것도 있다. 스핀락은 CPU에서 의미 없는 처리를 반복하면서 대기하지만, 단순히 계속 반복만 하는 것이 아니라 스핀해서 락을 확보하지 못하면 슬립하는 등 상황에 따라 스핀할지 슬립할지를 판단하는 방식(어댑티브 락)도 있다. 슬립해서 기다리면 컨텍스트 스위치가 발생하기 때문에 극히 단시간의 락에서는 CPU를 회전해서 기다리는 스핀락이 사용된다.

#### OS 커널에 사용되는 배타적 제어

리눅스 커널은 빅 커널락(Big Kernel Lock, BKL)이라 불리는, 하나의 스핀락으로 유지된다. 커널의 BKL이 이용되는 부분에서는 처리가 직렬화돼서 동시에 하나의 CPU만 커널 코드를 실행할 수 있다. 컴퓨터가 여러 CPU를 유용하게 활용해서 병렬 실행 가능한 처리를 늘리기 위해 리눅스 커널에서는 BKL로 보호된 커널 코드를 수정했다.

배타적 제어의 장단점

사용 경우
> 장점: 공유 데이터의 일관성을 유지할 수 있다.

> 단점: 병렬 처리가 안된다.

사용하지 않는 경우
> 장점: 병렬로 빠르게 처리할 수 있다.

> 단점: 데이터 불일치가 발생할 가능성이 있다.

#### 클러스터 데이터베이스의 배타적 제어

여러 DB 서버를 조합하는 경우에도 배타적 제어가 필요하다. CPU를 서버로, 프로세스나 스레드를 애플리케이션으로 바꿔서 생각하면 된다. 서버 간 배타적 제어가 발생하면 아무리 서버가 많아도 병렬 처리를 할 수 없기 때문에 이에 의한 대기 상태를 얼마나 줄일 수 있는지가 중요하다.

멀티 프로세서 시스템에서는 배타적 제어가 어렵다.
> 이런 경우 보통 하드웨어를 이용해서 배타적 제어를 구현한다. 구체적으로는 test and set이나 compare and swap(CAS)라 불리는 기능이 있다. 또한 CPU 코어 간 협력 처리를 통해 불일치가 발생하지 않도록 하는 구조도 있다.

CPU가 하나밖에 없으면 스핀락이 필요 없다.

### 상태 저장/ 상태 비저장

컴퓨터에서 상태 저장/비저장 개념은 거의 모든 곳에 적용되는 개념이다. 

정보를 많이 가지고 있는 상태 저장은 세분화된 제어가 가능한 반면에 구조가 복잡하다.

상태 비저장은 고기능은 아니지만 간단하다.

구체적인 예로 ssh는 상태 저장 프로토콜이지만 http는 상태 비저장 프로토콜이다.

어떤 작업을 하고 있을 때 현재 어디까지 작업이 진행됐는지와 같은 '상태'를 알아야 하는 경우가 있다.
시스템 처리를 하고 있을 때도 마찬가지다.
병원 진료 절차가 그 예시다.
슈퍼 등에서 물건을 사는 경우는 상태와 상관없다. 이를 상태 비저장이라 한다.

상태를 가진다는 것은 과거에 부여한 정보를 저장해서 계속 활용할 수 있다는 것을 의미한다.

상태의 단점으로는 시스템 복잡성이 약간 커진다는 것과 있을 수 없는 '상태'가 된 경우에 대한 대처도 필요하다는 것이 있다.

상태 비저장의 단점은 과거 정보를 가져올 수 없기 때문에 복잡한 처리가 어렵다는 것이 있다.

#### 컴퓨터 내부 구조

컴퓨터 내에서는 거의 모든 곳에 상태 저장이 사용되고 있다. CPU가 처리하는 프로세스는 코어당 하나다. 처리를 하지 않는 프로세스는 대기 상태로 있어야 한다. 이 절차를 효율적으로 처리하기 위해서 프로세스에서는 상태 전이를 한다.

#### 네트워크 통신 구조

브라우저가 http 서버에 특정 데이터에 대한 요청을 보내면 상태가 없기 때문에 매번 같은 데이터를 반환한다.
아이디와 비밀번호를 입력받아 회원 정보를 반환하는 경우 일부 상태 저장이라고 할 수 있다. HTTP는 세션이라는 개념을 사용해서 이 구조를 구현하고 있다. 즉, 인증을 거치면 상태를 저장함과 동시에 인증 완료 세션 정보를 반환한다.

### 가변 길이/ 고정 길이

데이터를 보관할 때 정해진 상자 안에 저장해야 한다. 이때 이 상자의 크기가 미리 정해져 있는 경우 고정 길이, 아닌 경우를 가변 길이라고 한다.

컴퓨터 내부 메모리나 디스크 등의 하드웨어 데이터 처리를 보면 고정 길이 상자가 모여 있는 형태다.

가변 길이는 공간의 낭비 없이 데이터를 잘 담을 수 있다. 하지만 같은 종류의 데이터가 흩어진다는 단점이 있다. 이런 경우 원하는 데이터를 찾기 힘들어진다.

고정 길이는 데이터 정리가 쉽다. 특정 위치에 어떤 데이터가 있는지 쉽게 알 수 있다. 대신 낭비되는 공간이 생겨서 효율적인 데이터 활용이 어렵다.

#### 실제 사용

윈도우에서는 NTFS라는 파일 시스템을 사용하는데, 여기는 파일을 고정 길이로 저장하고 있다. 

네트워크를 경유해서 데이터를 전송할 때에도 고정 길이로 할지 가변 길이로 할지를 고려해야 한다.

일반적인 이더넷의 MTU(Maximum Transfer Unit, IP 패킷의 최대 크기)는 1500바이트다. TCP/IP 헤더 합계가 40바이트이기 때문에 MSS(Maximum Segment Size)는 1460바이트가 된다. 
MTU,MSS는 고정 값이 아니라 환경에 따라 달라진다.

패킷은 일회용이기 때문에 가변 길이로 데이터를 처리해도 한쪽으로 편중되지는 않는다. 이더넷은 가변 길이 프레임이지만 고정 길이를 사용하는 것도 있다. ATM(Asynchronous Transfer Mode)이라는 데이터 링크 층의 프로토콜에서는 셀이라 불리는 53바이트 고정 길이 형식을 사용하고 있다.

### 데이터 구조 (배열과 연결 리스트)

상자를 빈틈없이 나열한 것이 배열이다. 상자의 번호만 알 수 있으면 바로 액세스할 수 있다.
상자를 선으로 연결한 것이 연결 리스트다. 첫 번째부터 순서대로 가지 않으면 액세스할 수 없다. (선으로 연결되었다는 것은 상자 하나가 다음 상자의 위치 정보를 담고 있다는 뜻이다.)

배열은 데이터를 추가하거나 삭제하는 경우 상자 전체를 옮겨야 하기 떄문에 느린 데이터 구조다.

연결 리스트는 선만 바꿔서 연결해주면 되기 때문에 데이터 추가, 삭제가 빠르다.

데이터 추가, 삭제가 빠른 연결 리스트와 탐색이 빠른 배열을 조합한 하이브리드형 데이터 구조가 해시 테이블이다.

해시 테이블은 오라클 DB의 SQL 정보 캐시 외에도 리눅스 등의 OS 커널에도 데이터 캐시나 KVS 등의 형태로 사용되고 있다.

#### 탐색 알고리즘(해시/트리 등)

- DB에서 인덱스를 사용하면 왜 검색이 빨라지는 걸까?
- 인덱스를 사용한다고 해서 항상 빨라지는 것이 아닌 이유는 왜일까?
- 기존 DBMS와 인메모리 DB에 적합한 인덱스가 다른 이유는 무엇일까?

해시나 트리는 탐색 알고리즘이 아닌 데이터 구조이지만, 효율적 탐색을 위해 사용된다. 필요한 때에 필요한 데이터를 신속하게 찾기 위해서는 데이터를 정리해 둘 필요가 있다.

데이터 정리 방법을 데이터 구조, 찾는 방법을 탐색 알고리즘이라고 한다.

- 데이터를 찾을 때의 데이터 구조와 데이터 저장 방식(메모리, HDD, SSD 등) 특성에 따라 적합한 데이터 정리 방법이 달라진다.

##### DBMS

인덱스가 없으면 디스크에서 테이블 데이터를 모두 읽어서 조사해야 한다. 테이블의 모든 블록을 처음부터 순서대로 읽어나가는 것을 풀 스캔(Full Scan)이라고 한다.

1. 쿼리 실행
2. 인덱스가 없어서 테이블 전체 데이터를 디스크에서 메모리로 옮긴 후 모든 데이터를 조사
3. 모든 블록을 꺼내서 읽고 특정 블록을 찾음
4. 해당 블록은 재사용을 위해 공유 메모리에 둔다.

DBMS 인덱스 종류로는 자주 사용되는 B 트리가 있다.
B 트리에는 B-, B+, B* 트리 등이 있다.

인덱스가 있으면 최소한의 필요 블록만 읽으면 된다. 사전을 찾을 때 색인을 이용하는 것과 마찬가지다. 
대신 단점도 존재하는데, 검색이 빨라지는 대신에 데이터 추가, 갱신, 삭제 시에 테이블뿐만 아니라 인덱스 데이터도 갱신해야 한다. 인덱스 갱신 때문에 불필요한 오버헤드가 발생할 수 있다. 

B 트리 인덱스 (이진 트리)
> 트리 형태로 블록을 정렬해두는 것을 말한다.
만약 테이블 데이터를 모두 취득해야 하는 경우 블록+ 인덱스 블록까지 읽어야 하기 때문에 디스크 I/O가 증가한다.

B 트리 인덱스가 DBMS에서 자주 사용되는 것은 트리 구조 계층이 깊어지지 않도록 디스크 I/O를 최소한으로 제어하기 때문인데, 메모리에 모든 데이터를 두는 인메모리 DB의 경우 디스크 I/O를 신경쓸 일이 없기 때문에 다른 접근 방법이 필요하다. 주로 T 트리 인덱스라는 이진 트리의 일종을 사용하는 경우가 있다.

이진 트리는 가지가 두 개밖에 없어서 계층이 깊어지지만, 키 값 비교 횟수가 적다는 이점이 있어서 메모리의 데이터 탐색에 적합하다.

해시 테이블
> 등호 검색(특정 조건을 만족하는 하나의 결과를 찾는 것)에 큰 강점을 보인다. 범위 검색은 약하다.
해시를 사용한 해시 인덱스를 사용하는 경우도 있다.



