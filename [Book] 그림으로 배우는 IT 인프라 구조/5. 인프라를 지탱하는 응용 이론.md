### 캐시

컴퓨터 용어인 캐시는 사용 빈도가 높은 데이터를 고속으로 액세스할 수 있는 위치에 두는 것을 의미한다.

캐시는 다음과 같은 특징이 있다:

- 일부 데이터를 데이터 출력 위치와 가까운 지점에 일시적으로 저장한다.

- 데이터 재사용을 전제로 한다.

캐시가 사용되는 곳:

- 브라우저 캐시
> 브라우저가 접속한 페이지를 캐시한다. 웹 서버 접속을 줄이고 브라우저 표시를 고속화할 수 있다. 

> 웹 서버 자체 부하를 줄이는 다른 한 가지 방법으로 웹 서버와 클라이언트 사이에 캐시 서버를 배치하는 방법이 있다. 요즘에는 캐시 서버를 서버 앞에 두는 대신에 CDN이라는 웹 서버가 아닌 다른 네트워크에 웹 콘텐츠 캐시를 배치하는 구조를 이용하기도 한다. 상용 서비스로는 아카마이(Akamai)등이 유명하다.

캐시에 적합한 시스템
- 참조 빈도가 높은 데이터
> 몇 번이고 같은 데이터를 참조한다면 캐시에 배치해서 고속으로 데이터에 액세스할 수 있다.
- 캐시의 데이터가 손실돼도 문제가 없는 시스템
> 스트리밍 데이터 등은 갱신이 없기 때문에 캐시에 장애가 발생해서 원 데이터를 다시 캐시해 배치하면 복원이 가능하다. 이런 읽기 전용 데이터에 적합하다.

캐시에 부적합한 시스템
- 데이터 갱신 빈도가 높은 시스템
> 갱신이 빈번하게 발생하는 경우는 갱신 시마다 캐시를 해야 해서 캐시의 메리트가 없다. 따라서 성능 향상을 기대할 수 없다.
- 대량의 데이터에 액세스하는 시스템
> 데이터 액세스 시에 수백 GB 이상의 큰 데이터를 참조하는 경우는 캐시 크기도 커진다. 캐시에 배치하기까지도 많은 시간이 걸린다. 예를 들어, 분석 시스템에서는 캐시에 데이터를 두는 것은 적합하지 않다.

캐시 설계시 주의할 점:
- 데이터가 실제 데이터와 캐시라는 이중 구조로 저장되기 때문에 리소스 소비가 늘어난다.
- 시스템 가동 직후 등에는 캐시에 데이터가 없기 때문에 원하는 성능이 나오지 않을 수 있다.
- 캐시 계층이 늘어나기 때문에 시스템 성능 문제나 데이터 불일치가 발생한 경우는 문제 발생을 야기한 용의자가 늘어난다.
- 캐시 데이터가 손실되는 경우를 대비해서 복구 순서를 설계 시에 확립해야 한다.
- 갱신 데이터를 캐시할 때 캐시가 여러 개 있으면 갱신된 최신 데이터를 서로 뺏으려는 상태가 발생하지 않도록 주의해야 한다.

### 끼어들기

급한 일을 먼저하도록 CPU에 알리는 것을 말한다.
애플리케이션 실행 도중 타이핑이 가능한 것도 끼어들기에 의한 것이다.

키보드로 입력하면 I/O 컨트롤러가 CPU에게 '키보드가 입력했어'하고 연락한다.
키보드로 입력하면 I/O 컨트롤러가 CPU에게 연락을 해서 키보드 입력이 처리된다.

끼어들기는 다양하다. 정기적으로 해야 할 일을 알려주는 타이머 끼어들기, 데이터를 메모리에 모두 읽었다는 것을 CPU에 알려주는 끼어들기, 에러가 발생했을 때 프로세스를 정지시키는 예외 처리 등이 있다.

사용되는 곳:

#### 네트워크에서 데이터를 수신할 때 발생하는 끼어들기
1. 이더넷 프레임이 NIC에 도착하면 끼어들기에 의해 CPU에 통지되고 데이터가 수신된다.
2. CPU를 사용하고 있던 프로세스 정보는 메모리로 옮겨지고 전송된 데이터가 커널 모드로 처리된다.
3. 끝나면 중단된 프로세스가 처리를 재개한다.

#### 조각화 위반 예외
1. 프로세스나 스레드가 허가되지 않은 메모리 위치에 액세스하려고 하면, '조각화 위반'이라 불리는 예외가 발생해서 OS에 의해 프로세스가 강제 종료된다. 이것도 끼어들기의 일종이다. 

끼어들기는 어떤 일이 발생하면 연락하는 '이벤트 주도' 구조다. 반면에 CPU가 정기적으로 폴링을 해서 입출력 장치 상태를 확인하는 방법도 있지만, 폴링 간격이 길면 디스크 I/O가 완료됐더라도 금방 알아차리지 못한다. 반대로, 간격을 짧게 하면 폴링을 자주 하기 때문에 CPU를 쓸데없이 많이 사용하게 된다. 

### 폴링

정기적으로 질의하는 것을 가리킨다. 정기적으로 질의함으로써 상대가 어떤 상태인지, 어떤 요구를 가지고 있는지 등을 알 수 있다.

폴링의 특징:
- 질의 방향이 단방향이다
- 질의는 일정 간격을 따라 정기적으로 발생한다.

폴링의 장점:
- 반복만 하면 되기에 프로그래밍이 쉽다.
- 상대가 응답하는지 확인할 수 있다.
- 모아서 일괄적으로 처리할 수 있다.

폴링이 사용되는 곳:
- 웹로직 서버에서 정기적인 폴링을 통해 접속 감시
- 폴링을 통한 시간 동기 (NTP) 처리

폴링이 적합한 곳:
1. 일정 간격으로 처리를 실행하면 좋은 처리
> 메일 시스템
2. 감시
> 외부에서 정기적으로 상태 확인

부적합한 곳:
1. 상태가 아닌 입력 내용에 따라 실행 내용을 변경하는 처리
> 키보드는 키를 누른 '상태'에 따라 처리 내용이 달라지는 것이 아니라 입력한 내용에 따라 처리가 결정되기 때문에 폴링으로 구현하는 것은 적합하지 않다. 이 경우는 이벤트나 끼어들기를 사용한다.
2. 처리 우선순위를 정해야 하는 처리
> 일정 간격으로 처리가 실행되기 때문에 처리 우선순위를 정할 수는 없다.

주의 사항
> 네트워크를 경유한 폴링일 때는 처리 지연 시간을 줄이기 위해 폴링 간격을 너무 짧게 잡으면 트래픽 양이 증가하므로 주의가 필요하다. 또한, 서버의 리소스 소비도 늘어난다.

### I/O 크기

I/O 크기란 1회의 I/O에 필요한 사이즈, 즉 데이터를 주고 받을 때 사용되는 I/O의 크기를 의미한다. 이 I/O 크기는 인프라 설계나 성능 튜닝에 있어 중요한 개념이다.

물건을 상자에 넣어서 나를 때 적절한 크기의 상자를 사용하면 쉽게 나를 수 있다는 얘기가 있다. 따라서 운반하는 양에 따라 적절한 크기를 정하는 것이 매우 중요하다.

오라클 DB 예시
> 오라클 DB에서 데이터 파일을 읽기/쓰기하는 최소 단위를 데이터 블록이라고 한다. 크기는 블록 크기라고 한다. I/O 크기와 블록 크기를 맞추는 것이 좋다. 

> 하위 계층도 의식할 필요가 있다. DB 블록 크기가 8KB이고 파일 시스템(예: ext3)의 블록 크기가 4KB라면 OS 계층에서 두 개 블록으로 분할된다. 디스크는 섹터라는 단위로 읽기/쓰기를 하는데, 일반적인 섹터 크기는 512바이트다. 섹터 크기는 하드웨어인 디스크의 사양이기 때문에 변경할 수 없고, 파일 시스템의 블록 크기와 데이터 파일의 블록 크기를 맞춰주는 수밖에 없다.

네트워크 예시:
> 웹 브라우저가 데이터를 전송할 때는 OS의 소켓이라는 구조를 사용한다. 웹 브라우저는 OS에 의뢰해서 소켓을 만들어 통신한다. 소켓을 작성하면 소켓 버퍼라는 상자가 만들어진다. 소켓 버퍼에는 송신 버퍼와 수신 버퍼가 있으며, 웹 브라우저가 송신하는 경우도 송신 버퍼에 쓴다. 이 버퍼가 차면 OS에 의해 TCP 세그먼트라는 상자로 분할되고, TCP 헤더, IP 헤더, MAC 헤더라는 편지 수신자 같은 정보를 붙여서 이더넷 프레임이라는 상자에 넣어 전송한다. 

> 송신 버퍼가 TCP 세그먼트로 분할될 때 MSS(Maximum Segment Size)를 초과하지 않는 범위에서 분할된다. IP 소켓의 최대 크기를 MTU라고 한다. PC로 인터넷을 할 때 의식할 필요는 없지만, 대량의 데이터를 고속으로 전송해야 하는 IT 시스템에서는 소켓 버퍼나 MTU 크기를 튜닝하기도 한다.

> 만약 경로 도중에 있는 라우터의 MTU의 크기가 작게 설정돼 있으면 서버가 송신하는 패킷이 더 작게 분할돼서 오버헤드가 발생하고, 결국 성능 저하로 연결될 수 있다.



### 저널링

저널은 트랜잭션이나 메일에 갱신되는 데이터의 변경 이력을 가리킨다. 저널을 남겨 두는 것을 저널링이라고 한다.
언제, 어디서, 무엇을 했는지 상세하기 기록하면서 시스템 장애가 발생했을 때 어디까지 정상처리됐고, 어디서부터 재실행하면 좋을지 알 수 있게 하는 기능이다.



저날의 특징:
- 데이터 자체가 아닌 처리(트랜잭션) 내용을 기록한다
- 데이터 일관성이나 일치성이 확보되면 필요 없어진다
- 데이터 복구 시 롤백, 롤포워드에 이용된다.

적용 사례:  
- 리눅스의 ext3 파일 시스템
> ext3 파일 시스템은 저널링 기능을 갖추고 있다.
파일 I/O도 트랜잭션으로 간주된다. 오라클 DB와 달리 트랜잭션 시에 버퍼 정보를 디스크에 기록하지 않기 때문에 버퍼에 있는 최신 데이터를 잃을 수도 있다.

> 기본 설정에서는 5초에 한 번 기록이 되지만, 데이터 파손이 허용되지 않는 경우에는 이 간격을 짧게 설정하는 것이 좋다. 
1. 사용자 프로세스가 파일 갱신을 요청한다.
2. 저널의 I/O 트랜잭션이 시작된다.
3. 메타 데이터가 저널로 복사된다.
4. 실제 데이터와 메타 데이터가 메모리상에서 갱신된다.
5. Kjournald에 의한 저널 기록 처리 전에 bdflush를 이용해서 캐시의 데이터가 디스크에 기록된다.
6. 데이터 기록 후에 저널을 출력한다(커밋)
7. 커밋 후, 데이터가 디스크 기록돼 있으며, 불필요한 저널을 개방한다. (체크포인트)
8. 메타 데이터가 비동기적으로 출력된다.

- 오라클 DB
> 오라클 DB 저널은 REDO 로그라 불린다. 오라클 이외의 DB에서는 WAL(Write Ahead Log. 로그 선행 쓰기)이라고 부르기도 한다. 트랜잭션 종료 시(커밋 시)에 버퍼가 디스크에 기록되지만, 기록 중인 REDO 로그(현재 REDO 로그라고 한다)가 파손된 경우에는 데이터를 최신 상태로 복원할 수 없다. 이 때문에 오라클 DB에서는 REDO로그를 이중화해서 보호한다.
1. 변경한 블록을 데이터 파일에서 읽어서 버퍼 캐시에서 변경한다.
2. 변경 내용을 로그 버퍼에 기록한다.
3. 커밋이 실행된 시점에 LGWR이 버퍼를 로그 파일에 기록하고, 기록이 끝난 것을 서버 프로세스에게 통지한다.
4. REDO 로그는 재활용하기 때문에 옛날 REDO 로그를 덮어쓰기 하기 전에 아카이브하는 경우도 있다.
5. 변경된 데이터는 버퍼 캐시가 꽉 찬 시점에 DBWR에 의해 출력된다.

저널링 장점:
- 시스템 장애 시 복구가 빠르다
- 데이터 복제보다도 적은 리소스를 소비해서 데이터를 보호할 수 있다.

적합한 시스템:
1. 데이터 개인이 발생하는 시스템
> 데이터를 갱신하는 시스템에서는 트랜잭션 내용을 기록해 둠으로써 데이터 안정성을 높일 수 있다.
부적합한 시스템:
1. 데이터 안정성보다 성능을 요구하는 시스템
> 저널링을 하면 기록 처리 시 오버헤드가 발생하기 때문에 성능을 중시하는 시스템이라면 이 오버헤드를 줄일 방법을 검토해야 한다. 즉, 캐시 서버 등 실제 데이터가 다른 장소에 있는 서버에서는 부적합하다.

복구 과정
- 롤백은 저널을 읽어서 실제 데이터 정보를 과거로 되돌리자는 처리이고, 롤포워드는 저널을 읽어서 실제 데이터 정보를 앞으로 진행시키는 처리다.

저널링 주의점:
- 저널 데이터는 메모리의 버퍼에 일단 저장된다. 이 정보가 디스크에 기록되지 않으면 장애 시에 잃을 수 있다.
- 저널은 트랜잭션 단위로 일치성을 보증하기 때문에 트랜잭션 도중에 장애가 발생하면 종료되지 않은 트랜잭션은 파괴된다. 하나의 트랜잭션 단위가 크면 트랜잭션 도중에 장애가 발생할 가능성이 높다. 따라서 트랜잭션이 길어지지 않도록 설계해야 한다.

### 복제

복제는 DB나 저장소 등에서 자주 사용되는 기술이다. IT 시스템에서는 각종 재해에 대비해서 멀리 떨어진 장소에 데이터 센터를 구축해서 예비 시스템에 데이터를 복제하는 경우가 있다. 대규모 웹 서비스에서는 대량의 사용자 접속에 대비해서 동일 데이터를 여러 서버에 복제해서 부하분산을 하기도 한다. 복제 목적은 다양하며, 구조도 여러 가지가 있다.

복제는 복사본을 만드는 것을 의미한다. 복사본이 있으면 원래 데이터가 없어져도 다른 것으로 대체할 수 있다. 또한, 복사본을 활용해서 부하를 분산할 수도 있다. 한 부만 있는 자료를 여러 사람이 읽으려면 복사를 해서 각자에게 자료를 제공하는 것이 좋다.

복제의 주요 특징으로 다음 두 가지를 들 수 있다.
- 장애 시 데이터 손실을 예방할 수 있다.
- 복제를 이용한 부하분산이 가능하다.

사용되는 곳:
- 저장소 복제
1. 데이터가 갱신돼서 '갱신 블록'과 매핑된다.
2. 갱신된 순서대로 네트워크 경유로 데이터가 전송된다.
3. 갱신이 반영된다.
4. 데이터 보호를 최우선으로 하는 경우, 복제 서버 측 데이터가 갱신된 후에야 서버 기록 처리가 끝났다고 통지하는 경우도 있다.

- MySQL 복제
1. 데이터 변경 SQL을 바이너리 로그에 기록한다.
2. 워커 DB의 I/O 스레드가 바이너리 로그를 취득해서 릴레리 로그로 저장한다.
3. SQL 스레드가 릴레이 로그를 참조해서 DB에 변경 SQL을 반영한다.
> MySQL 복제는 데이터 '추가,갱신, 삭제' 등의 변경 처리를 복제 측으로 보낸다. 실제 데이터 블록을 전송하는 것이 아니기 때문에 복제 데이터 전송량을 줄일 수 있다. 복제 전송량은 트랜잭션 수와 비례한다.

복제에 적합한 시스템
- 데이터 손실을 허용하지 않고 장애 시 복구 속도가 빨라야 하는 시스템
- 데이터 참조와 갱신 부분이 나뉘어져 있으며, 참조가 많은 시스템

복제에 부적합한 시스템
- 데이터 갱신이 많은 시스템
> 데이터 갱신이 많은 시스템에 적용하면 복제 대상 데이터가 많아지기 때문에 오버헤드가 높아진다.

1. 복제 위치가 많으면 갱신이 많은 시스템과 같이 복제 오버헤드가 높아진다.
2. 실제 데이터와 복제 데이터를 완전히 일치시키고 싶으면 복제 데이터의 쓰기 완료 처리를 보장해야 한다. 이 경우 시스템 응답이 악화될 수 있다.
3. 시스템 유지관리나 장애 시에는 복제 데이터도 고려해야 하므로 설계나 운용 난이도가 높아질 수 있다.
4. 복제 데이터와 실제 데이터의 차이가 커지면 그 차이를 채우기 위한 시간이나 성능도 고려해야 한다.

### 마스터-워커

주종 관계를 가리킨다. 이 구조에서는 한 명이 관리자가 돼서 다른 모든 것을 제어하게 된다. 

예: 가족이 돈을 관리할 때 한 명이 가계 관리를 하고 나머지는 용돈을 받아서 쓰는 것.

같은 리소스를 여러 사람이 분담해서 관리할 때는 '누가', '어디까지' 감시하고 있는가에 대한 정보를 알 필요가 있다. 관리 정보를 매번 상호 통신으로 교환하면 부하가 높아져서 비효율적이다.

만약 관리 대상 리소스를 공유하고 있지 않다면 마스터가 필요 없고 피어 투 피어 관리가 효율적이다. 리소스를 공유하고 있는 경우이지만, 리소스가 무한대로 있다고 가정하면, 각자가 마음대로 관리해도 문제가 없기 때문에 피어 투 피어라도 괜찮다.

#### 오라클 Real Application Clusters(RAC)

RAC의 마스터-워커 구성을 보면 여러 대의 물리 서버가 클러스터 구성으로 연결돼 있다. 특정 서버가 마스터가 되는 것이 아니라, 모두가 대등한 관계라서 특정 서버가 다운돼도 db 전체 가용성에는 영향을 주지 않는다. 

db의 데이터를 하나의 물리 서버가 모두 관리하는 것이 아니라, 리소스 단위로 관리 마스터가 달라진다. 만약 물리 서버가 다운된다면 해당 서버가 마스터로 관리하고 있던 리소스는 다른 마스터 서버가 관리하게 된다.

하나의 물리 서버가 관리하고 있다면 이런 문제가 발생했을 시에 작업 인계 시간이 오래 걸려 위험하지만, RAC에서는 분담해서 관리하고 있으므로 다른 서버로의 작업 인계가 단시간 내에 가능하다.

마스터-워커 장점
- 관리자가 한 명이기 때문에 구현이 쉽다.
- 워커 간 처리를 동기화할 필요가 없기 때문에 통신량이 줄어든다.

마스터-워커 단점
- 마스터가 없어지면 관리를 할 수 없다.
- 마스터의 부하가 높아진다.

### 압축

디지털 데이터는 '압축'을 할 수 있다. 압축 기술은 대부분의 통신 기술 등 거의 모든 곳에서 사용되고 있다. 

디지털 데이터에서는 정보의 낭비를 막으면 압축을 할 수 있다. 낭비되는 정보란 '자신에게 필요 없는 정보'나 '이미 알고 있는 정보'를 들었을 때 의미없는 정보라고 생각할 것이다.
예를 들어 Central Processing Unit을 CPU라고 처음부터 선언해 두면, 매번 길게 쓰지 않아도 돼서 정보가 압축된다. 

디지털 데이터 압축의 기본은 '중복 패턴 인식'과 그것을 '변경'하는 것이다. 중복이 많을수록 압축률이 높아진다. JPEG 등의 이미지 파일은 이미 압축돼 있어서 중복 패턴이 거의 없는 상태로 압축해도 크기에 변화가 없다.

압축에는 처리 시간이 필요하다. zip 압축처럼 빈도가 높은 패턴을 우선적으로 찾아서 변경하는 방식에서는 데이터 전체를 한 번 읽어야 해서 시간이 걸린다.

압축을 하는 장점은 데이터 크기를 줄이는 것이고, 단점은 처리 시간이 걸린다는 것이다. 즉, 데이터 크기와 시간이 상충된다. 이런 이유로 자주 변경되지 않는 데이터에 효과적이다. 네트워크 경유의 데이터 전송 등 I/O 속도가 느린 환경에서는 미리 압축해서 전송하면 전체적인 처리 시간을 줄일 수 있다.

압축에는 가역, 비가역 압축이 있다. 가역 압축은 '이미 알고 있는 정보'를 제거하는 압축 방식이고, 비가역 압축은 '자신에게 필요 없는 정보'를 제거, 즉 최소 필요 정보만 남겨 두는 압축 방식이다. 예로 이미지나 음성 데이터 등에 있는 사람이 인식할 수 없는 부분을 생략하는 것이 있다.

db나 저장소 서버에서도 압축이 사용된다. 하지만 압축에 시간이 걸려서 쓰기 속도가 떨어지면 곤란하기 때문에 비교적 간단한 압축 구조를 사용하는 경우가 많다. 자주 사용되는 것으로 중복 제거(deduplication)라 불리는 것이 있다. 기록할 데이터를 일정 단위 블록으로 처리해서 중복된 것을 제거하는 기능이다. 데이터를 기록할 때는 블록의 해시 값을 계산해서 아직 기록되지 않은 블록을 저장하고 기록된 것은 저장하지 않는다. 결과적으로 같은 파일은 당연히 같은 블록으로 구성되기 때문에 몇 개를 저장해도 실제로는 한 개분의 디스크 공간만 차지한다.

### 오류 검출

컴퓨터의 다양한 곳에서 데이터 교환이 발생한다. 인터넷에서 누군가의 블로그를 읽을 때도 데이터 교환이 발생한다. 그런데 의도하지 않은 때에 데이터가 망가질 수도 있다. 이를 방지하기 위해 오류 검출이라 불리는 구조가 있다.

디지털 데이터는 자연적인 현상으로 인해 전류나 전압 변화에 영향을 받아 파손될 수 있다.

틀린 데이터를 받는 경우 당연히 이것이 틀렸다고 판단할 수가 없다. 전송된 데이터와 별도로 추가 정보가 필요하다. 

#### 패리티 비트

비트에서는 반드시 1이라는 수가 짝수 개 혹은 홀수 개가 되도록 1비트만 추가한다. 이렇게 이중화 비트를 부여해서 1비트까지 오류를 검출할 수 있다. 하지만 그 이상의 비트가 변화됐다면 오류를 인지할 수 없다. 

패리티 비트 이외에도 체크섬, CRC 등 다양한 기법이 존재한다. TCP와 IP 헤더에는 체크섬, 이더넷 트레일러에는 CRC가 있다.

검출뿐만 아니라 파손된 데이터를 바로 수정할 수 있는 '오류 수정'이라는 구조도 있다. 오류 수정에선 검출 때보다 많은 추가 데이터를 부여해야 한다.