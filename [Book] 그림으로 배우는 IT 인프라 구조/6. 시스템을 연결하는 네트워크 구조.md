### 네트워크

데이터는 반드시 네트워크를 경유해서 다른 장비로 전달된다.

데이터가 장비 간 어떻게 전달되는지 알기 힘들다. 그 이유는 네트워크 자체가 그 구조를 알지 못해도 사용할 수 있도록 돼 있기 때문이다.

네트워크에서 발생하는 데이터 처리나 교환에는 다양한 구조가 존재한다. 하지만 인터넷 통신 구조를 포함해 3계층형 시스템 등을 구성하는 경우는 대부분 TCP/IP라는 구조를 사용한다. TCP/IP는 다양한 통신 환경에서 데이터를 잘 전달해 주는 우수한 구조다. 그리고 OS가 이 TCP/IP를 사용해서 간단히 통신할 수 있는 구조를 제공한다.

### 계층 구조

컴퓨터 세계는 많은 부분에서 계층 구조라는 개념을 적용하고 있다.

계층 구조는 역할을 분담하는 것이라고 생각할 수 있다. 역할이 나뉘어 있기 때문에 각 층은 자신이 담당하는 일만 책임을 지고 다른 일은 다른 계층이 책임을 진다. 각 층은 상호 간에 어떤 일을 하는지 알고 있지만, 구체적으로 어떤 방식으로 처리하고 있는지는 알지 못한다. 계층과 계층 사이에는 연결을 위한 인터페이스만 존재한다. 상호 간에 연결되는 계층은 공통의 인터페이스를 가진다.
단점은 작업 효율을 희생해야 한다는 점이다. 작업 인계를 할 때는 오버헤드가 발생한다.

계층 모델의 대표적인 예로 OSI 7계층 모델이 있다. OSI 자체는 현재 사용되고 있지는 않지만, 개념은 다양한 분야에서 공통적으로 참조할 수 있는 '참조 모델'로서 현재도 사용되고 있다. 참조 모델이 되면서 엔지니어가 서로 공용할 수 있는 일종의 공통 언어 역할도 하고 있다.

### 프로토콜

프로토콜은 컴퓨터가 서로 소통하기 위해 정한 규약을 가리킨다. 언어도 사람끼리의 통신을 위한 프로토콜이라 생각할 수 있다.
통신 시에 이용하는 매체도 프로토콜이라 볼 수 있다. 대화할 때 소리를 사용하는 경우가 많은데, 이것은 음성이라는 통신 프로토콜 위에 한국어라는 통신 프로토콜을 올려 놓은 것이라고 볼 수 있다.

컴퓨터의 거의 모든 곳에 프로토콜이 사용된다. 떨어진 곳에 있는 두 개의 장비는 사전에 절차를 정해 두지 않으면 서로 통신할 수 없다.

컴퓨터로 만들어진 제조사가 다르면 서로 대화하는 언어를 일치시켜야 통신이 가능하다. 다른 제조사에서 만들어진 컴퓨터가 서로 통신하기 위해서는 프로토콜을 일치시켜야 한다. 이 때문에 네트워크 업계에서는 공통 프로토콜 선정을 위한 (IEEE,IETF) 같은 표준화 단체가 존재한다.

어떤 장비라도 서로 통신을 하기 위해서는 프로토콜이 필요하다.
PC에 연결하는 USB를 위한 프로토콜, 저장소에서 데이터를 꺼낼 때의 프로토콜, 멀티 코어 CPU에서 CPU끼리 통신하는 데 사용하는 프로토콜 등 다양하다.

### TCP/IP를 이용하고 있는 현재의 네트워크

과거에 OSI 7계층 모델이 있었지만 현재는 TCP/IP 및 관련 프로토콜을 사용하며 통틀어서 TCP/IP 프로토콜 스위트라고 한다.
TCP/IP에서는 계층이 7개로 분명하게 나누어지지 않는다. TCP/IP 4계층 모델 등으로 불리며. OSI 7계층의 1~2 계층을 모아서 링크 계층, 5~7 계층을 모아서 애플리케이션 계층으로 취급하기도 한다.

TCP/IP 모델에서는 애플리케이션 계층, 즉 httpd 프로세스가 소켓을 통해 TCP/IP에게 통신을 위임한다. 커널 레벨에서 TCP/IP 그리고 이더넷이 필요로 하는 정보를 데이터에 부여해서 최종적으로 이더넷 프레임을 만든다. 이것이 NIC에 전달돼서 이더넷 케이블 등을 통해 인접 노드를 경유해서 최종 위치까지 전달된다.

실제 현장에서 계층을 숫자로 부를 때는 OSI 참조 모델의 7계층 방식으로 부르는 경우가 많다. 링크 계층, 즉 이더넷 계층을 레이어 2나 L2로, IP 계층을 레이어 3나 L3, 전송 계층을 레이어 4나 L4라고 부른다. 각 계층별 처리를 하는 네트워크 스위치를 레이어 2 스위치나 레이어 3 스위치라고 부르는 것도 이 때문이다. 애플리케이션 계층은 그대로 애플리케이션 레이어로 부르거나 L7라고 부르는 경우도 있다.

### [레이어 7] 애플리케이션 계층의 프로토콜 HTTTP

애플리케이션이 없으면 통신이 시작되지 않는다. 애플리케이션이 사용하는 프로토콜을 모두 애플리케이션 계층 프로토콜이라 부른다. 애플리케이션 계층 프로토콜은 자신이 통신을 하는 것이 아니라 통신 자체는 모두 OS, 즉 TCP/IP에 맡긴다.

브라우저에 URL을 입력해서 요청이 웹 서버에 도착하면 응답으로 HTML 파일이 반환된다. 브라우저는 이 파일을 해석해서 파일 내에 추가 이미지나 스크립트 등이 포함돼 있으면 웹 서버에 이들을 다시 요청한다. 이렇게 클라이언트와 웹 서버는 HTTP를 통해서 요청과 응답을 주고받는다.

요청을 하게되면 서버에 명령을 던진다. GET은 파일 요구이고, POST는 데이터를 전송한다는 의미다. 헤더 부분에는 다양한 부가 정보가 들어가며 세밀한 제어를 위해 사용한다. 예를 들어, User-Agent는 브라우저 식별 정보를 가지고 있으며, Cookie는 세션 식별자로 사용된다.

애플리케이션 프로토콜에서 HTTP 통신은 소켓에서 이루어진다. 소켓에 데이터를 기록하면 다른 한쪽의 소켓으로 전달된다. 이와 같이 애플리케이션 자체가 통신 구조를 가지지 않고서도 원격지에 있는 서버 애플리케이션과 통신할 수 있다.

애플리케이션 프로세스가 네트워크 통신을 하는 경우, 커널에 "TCP/IP로 통신하고 싶으니까 상대방 애플리케이션과 통신할 수 있는 회선을 열어줘"라고 의뢰한다. 의뢰 방법은 시스템 콜이다. 접속 대상 서버의 IP 주소와 TCP 포트, 두 가지 정보가 필요하다. 이 두 가지 정보는 각각 IP 도착 위치와 TCP 도착 위치다.

의뢰를 받은 커널은 소켓을 만들어 준다. TCP, IP에 대한 정보를 시스템 콜 경유로 커널에 전달하면, 접속 대상 서버와의 연결이 생성된다. 이때, 상대방 서버에서도 소켓이 만들어지며, 상대 서버와 이어지는 가상 경로(virtual circuit)가 생성된다. 실제 데이터는 물리적인 통신 케이블을 통해 긴 여정을 거쳐서 겨우 상대방에게 전달되는 것이지만, 프로세스 관점에서는 소켓이라는 구멍에 넣은 데이터가 가상 경로를 통해서 상대 통신 소켓 구멍으로 나오는 것이다.

### [레이어 4] 전송 계층 프로토콜 TCP

소켓에 기록된 애플리케이션 데이터는 커널 내에서 통신 대상에게 전달될 준비를 한다. 먼저 TCP 프로토콜이 있다.

TCP의 역할은 애플리케이션이 보낸 데이터를 그 형태 그대로 상대방에게 확실하게 전달하는 것이다.

TCP가 담당하는 것은 서버가 송신할 때와 서버가 수신한 후 애플리케이션에게 전달할 때다. 상대 서버까지 전송하는 부분은 하위 계층인 IP에 모두 위임한다. TCP에 의존하지 않고 IP만으로도 통신할 수 있지만, 데이터가 온전히 전달되는 것을 보장할 수 없다.

TCP 기능 요약:

1. 포트 번호를 이용해서 데이터 전송
2. 연결 생성
3. 데이터 보증과 재전송 제어
4. 흐름 제어와 폭주 제어 (공평한 통신을 위함)

소켓에 기록된 애플리케이션 데이터는 소켓의 큐를 경유해서 소켓 버퍼라 불리는 메모리 영역에서 처리된다.
소켓 버퍼는 소켓별로 준비된 전용 메모리 영역으로, 이후 계속되는 IP나 이더넷까지의 일련의 처리도 소켓 버퍼 내에서 이루어진다.

TCP는 데이터를 세그먼트라고 하는 단위로 관리하고 있다. 이 떄문에 애플리케이션 데이터에 TCP 헤더를 붙여서 TCP 세그먼트를 작성한다. 헤더에는 도착 지점 포트 번호를 포함해서 TCP 기능을 표현하기 위한 수많은 정보가 기록된다. 하나의 TCP 세그먼트로 전송할 수 있는 최대 데이터 크기를 MSS(Maximum Segment Size)라고 한다. 최종적으로 링크 계층을 사용해서 데이터를 전송하기 때문에 MSS는 링크 계층에서 전송할 수 있는 최대 크기에 의존하며, 환경이나 설정에 따라 달라진다. 링크 계층에서 전송할 수 있는 최대 데이터 크기를 MTU(Maximum Transfer Unit)라고 한다.

1. 소켓에 기록된 데이터는 큐를 경유해서 커널 내 네트워크 처리 부분에 전달된다.
2. 커널에 전달된 데이터는 '소켓 버퍼'라는 메모리 영역에서 처리된다.
3. 하나의 TCP 세그먼트로 전송할 수 있는 최대 크기를 MSS라고 하는데, MSS를 초과한 데이터는 자동적으로 분할돼서 복수의 TCP 세그먼트가 생성된다.
4. 데이터에 TCP 헤더를 붙여서 TCP 세그먼트를 생성한다. TCP 헤더에는 목적 애플리케이션의 포트 번호 신호를 포함해 TCP 기능에 필요한 다양한 정보가 기록된다.

2000바이트의 애플리케이션 데이터가 있다고 가정하자. MSS는 보통 1460바이트이기 때문에 데이터는 1460바이트와 540바이트로 쪼개진다. 그리고 각 데이터에 TCP 헤더가 붙게되고 두 개의 TCP 세그먼트가 완성된다.

상대 서버에 데이터가 도착했다고 해도 어떤 애플리케이션용 데이터인지 알 수 없다. TCP에서는 포트 번호를 사용해서 어떤 애플리케이션에 데이터를 전달할지 판단한다. TCP 포트 번호는 0~65535를 이용한다.

TCP는 소켓을 생성할 때도 중요한 역할을 한다.
TCP는 연결형 프로토콜로, 연결이라 불리는 가상 경로를 생성한다.
TCP가 통신을 시작하면서 통신 상대에게 '지금부터 통신한다'라고 연락한 후 'OK' 사인을 받으면 그때 처음 생성된다.
물론, 통신을 받으려면 통신을 받는 애플리케이션 측이 미리 통신 준비를 하고 있어야 한다. 서버 프로세스는 OS에게 '포트번호 00에게 통신 의뢰가 오면 나에게 연결해'라고 부탁한다. 이렇게 서버 측 소켓은 자신이 지정한 포트 번호에 통신이 오는지를 기다렸다가 받는다. 이 상태를 '포트를 리슨'하고 있다고 한다.

통신을 시작하고 싶은 프로세스는 커널에게 통신 개시를 의뢰한다. 이 커널은 가상 경로를 생성하기 위해 상대방과 대화를 시작한다. 먼저, 통신 상대인 서버 측 OS에게 가상 경로를 열도록 의뢰한다. 서버 측에는 리슨하고 있는 포트 번호로 통신 요구가 온다. 서버는 문제가 없으면 열어도 된다는 응답을 한다. 클라이언트도 이를 확인했다는 메시지를 보내며, 이때 처음으로 통신용 가상 경로가 열린다. 이 세 번의 대화를 TCP/IP의 3-way handshaking이라 한다.

이 연결은 애플리케이션, 즉 두 개의 소켓 사이에 전용 회선이 있는 것처럼 통신한다. 구체적으로는 어떤 동작을 할까? TCP 통신을 시작할 때 상대 서버에 포트 번호와 연결을 열어달라고 부탁만 할 뿐 다른 특별한 일은 하지 않는다. 데이터 전송 자체도 IP에 위임하기 때문에 실제 물리적인 경로가 막히거나 통신 상대 서버가 갑작스런 장애로 전원이 꺼져도 가상적인 경로인 TCP 연결이 끊어지진 않는다. 이런 상태에서는 데이터가 전달되진 않지만, 기본적으로 애플리케이션이 OS에게 연결 절단 의뢰를 하거나 통신 대상이 에러를 보내오지 않는 이상 TCP 연결 자체가 유지되기 때문에 주의가 필요하다.

참고로, 통신을 받는 서버 측은 미리 지정한 포트 번호를 리슨하지만, 통신을 시작하는 클라이언트 측에서는 보통 자신이 사용하기 위한 포트 번호를 지정할 수 없다. 이때는 OS에 의해 클라이언트 측에서 사용하지 않는 포트 번호가 자동으로 할당된다.

#### 데이터 보증과 재전송 제어

데이터 손실을 방지하는 구조는 확인 응답과 재전송에 의해 구현된다. 수신 측에 TCP 세그먼트가 도착하면 수신 측은 송신 측에 도착했다는 것을 알린다. 이때 반환하는 것을 ACK라고 하며, TCP 헤더에 ACK 관련 정보를 넣은 TCP 세그먼트를 반환한다. 송신 측은 ACK가 돌아오는 것을 보고 전송한 세그먼트가 무사히 도착했다는 것을 알 수 있다. ACK가 오지 않으면 전송한 TCP 세그먼트가 어떤 이유로 사라졌을 가능성이 있다. 언제든지 재전송이 가능하도록 전송이 끝난 TCP 세그먼트라도 ACK가 돌아오기까지는 소켓 버퍼에 남겨 둘 필요가 있다.

데이터 순서는 TCP 세그먼트에 시퀀스 번호라고 하는 숫자를 붙여서 구현한다. 시퀀스 번호도 TCP 헤더에 기록되며, 해당 TCP 세그먼트가 가지고 있는 데이터가 전송 데이터 전체 중 몇 바이트째부터 시작하는 부분인지를 가리키고 있다. 이런 순차적 조합을 위해 수신 측은 ACK를 반환할 때 다음에 필요한 TCP 세그먼트의 시퀀스 번호도 ACK 번호로 전달한다. 예를 들어, 3000바이트의 데이터를 1460, 1460, 80 바이트의 세 가지 TCP 세그먼트로 분할을 했다고 하면, 두 번째 시퀀스까지 수신 완료했다면 세 번째 세그먼트를 필요로 하기 때문에 '다음 시퀀스 번호는 2921부터 보내'라는 내용으로 응답한다.

ACK가 오지 않으면 재전송을 한다. 재전송을 하는 시점은 첫번쨰는 타임아웃이다. 일정 시간 내에 ACK가 돌아오지 않으면 재전송한다. 다음으로는 같은 시퀀스 번호를 세 번 요청했을 경우다. 세 번을 중복해서 요청하는 경우, 즉 같은 ACK가 3번 들어오는 경우 데이터가 늦게 도착하는 것이 아니라 도착하지 않았다고 간주하고 다시 보내게 된다.

#### 흐름 제어와 폭주 제어

동기로 통신을 하면 효율이 나쁘기 때문에 ACK를 기다리지 않고 전송하는 것이 좋다. TCP는 어느 정도의 세그먼트 수라면 ACK를 기다리지 않고 전송하는 윈도우라는 개념을 갖고 있다. ACK를 기다리지 않고 전송 가능한 데이터 크기를 윈도우 크기라고 한다. 윈도우는 수신 측의 수신 윈도우와 송신 측의 송신 윈도우가 있다. 기본적으로는 수신 윈도우와 폭주 윈도우 중 작은 쪽을 송신 윈도우로 채택한다. 이 윈도우 범위 내에서는 ACK를 기다리지 않고 전송한다. ACK가 오면 해당 TCP 세그먼트는 재전송할 필요가 없기 때문에 송신용 소켓 버퍼에서 삭제하고 송신 윈도우를 다음으로 이동한다. 이와 같이 윈도우를 이동해 가는 방식을 슬라이딩 윈도우라고 한다. 수신 측은 수신용 소켓 버퍼가 넘쳐서 더 이상 수신이 불가능하게 되면 수신 윈도우 크기를 작게 만들고 이 사실을 송신 측에 알린다. 송신 측은 수신 윈도우 크기 이상의 데이터는 ACK 없이 보낼 수 없게 된다. 이것이 TCP 흐름 제어(유량 제어)다.

송신 측 윈도우를 폭주 윈도우라고 부르는 이유는 송신 측 윈도우 크기가 네트워크 폭주 상태(혼잡 상태)에 맞추어 변경되기 때문이다. 네트워크가 혼잡하면 폭주 윈도우 크기를 작게 해서 전송 데이터 양을 줄인다. 이것이 폭주 제어다. 폭주 윈도우 크기는 통신 시작 시 1세그먼트에 설정된다. 통신이 문제 없이 시작돼서 수신 측에 도착하면 ACK 반환 시마다 폭주 윈도우 크기를 2세그먼트, 4세그먼트 식으로 지수 함수적으로 늘려나간다. 이 방식을 슬로우 스타트라고 한다. 어느 정도의 크기까지 증가하면 그 이후는 1세그먼트씩 크기를 늘려나간다. 송신 중인 세그먼트가 실패하면, 즉, 폭주를 감지하면 폭주 윈도우 크기를 작게 해서 송신량을 줄인다. 그리고 다시 폭주 윈도우 크기를 크게 만든다. 이 변화를 반복함으로써 주변에 민폐를 끼치지 않고 자신의 전송 속도가 최대가 되도록 조정할 수 있다.

### [레이어 3] 네트워크 계층의 프로토콜 IP

TCP 세그먼트가 만들어지면 다음은 IP 처리가 시작된다.
IP에는 프로토콜 종류에 따라 다른 버전인 IPv4와 IPv6가 있다. 기업형 시스템에서는 대부분 IPv4를 쓰고 있다.

#### IP의 역할

간단히 설명하면 '지정한 대상 서버까지 전달받은 데이터를 전해 주는 것'이라 할 수 있다. 간단하지만 TCP/IP 중에서도 가장 중요한 기능이다. 단, IP에서는 반드시 전달된다고 보장하지 않는다. IP가 담당하는 기능은 중요하지만 종류는 그다지 많지 않다. 중요한 기능은 다음과 같다.

1. IP 주소를 이용해서 최종 목적지에 데이터 전송
2. 라우팅(Routing)

#### 커널 공간의 IP 처리 흐름

커널 내에서 이루어지는 IP 처리 흐름은 다음과 같다.

- 생성된 세그먼트는 IP 처리에 돌입한다.
- IP 계층에서는 최종 목적지가 적힌 IP 헤더를 TCP 세그먼트에 추가해서 IP 패킷을 생성한다.
- 헤더에는 목적지 IP 주소 외에 저장하고 있는 데이터 길이, 프로토콜 종류(TCP 등), 헤더 체크섬 등이 기록된다.

기본적으로 IP 패킷은 TCP에 의해 링크 계층에서 최대 전송 크기로 분할돼 있기 때문에 여기에 IP 헤더만 추가한 것이다. 참고로, TCP 헤더는 20바이트이고, IP 헤더도 기본적으로 20바이트이기 때문에 이 시점에 첫 번째 IP 패킷은 실제로는 1460+20+20으로 1500바이트가 된다.

#### IP 주소를 이용한 최종 목적지로의 데이터 전송

IP에서는 최종 목적지 서버까지 복수의 네트워크를 경유해서 데이터를 전송한다. 이때 이용되는 것이 대상 서버를 나타내는 IP 주소다.

IP 주소는 32비트로 표현된 숫자 집합이다. 컴퓨터에서 처리하는 숫자이기 때문에 원래는 이진수를 써야 하지만, 사람이 읽기 쉽도록 8비트 단위로 마침표를 찍어서 표현하는 것을 자주 볼 수 있다.

IP 주소는 네트워크부와 호스트부로 나뉜다. 네트워크부는 어떤 네트워크인지를 가리키고, 호스트부는 해당 네트워크 내에 있는 컴퓨터를 가리킨다. 즉, IP 주소로 '어디의', '누구'인지를 알 수 있는 것이다. IP 주소에서 어디까지가 네트워크부인지 표시를 하기 위해서 /24 같은 CIDR(사이더) 표기를 사용한다. 서브넷 마스크라고 해서 255.255.255.0과 같이 표현하기도 한다. 같은 네트워크 내 컴퓨터의 IP 주소는 네트워크부를 동일 값으로 설정해야 한다. (호스트부의 비트가 모두 1인 주소는 브로드캐스트 주소라 불리는 특수한 주소다. 브로드캐스트 주소로 보낸 패킷은 같은 네트워크의 모든 호스트에 전달된다.)

IP 주소는 보통 192.168로 시작한다. 이는 특정 범위 내에서 사용하는 네트워크, 즉 사설 네트워크에 대한 표준이다 (RFC 1918). 사설 주소는 보통

- 10.0.0.0/8
- 172.16.0.0/12
- 192.168.0.0/16

이다. 192.168.0.0/24를 쓰는 경우도 있다. 사설 주소의 반대되는 개념으로 인터넷상에서 통신이 가능한 IP 주소를 공공 IP주소하고 한다.

사설 주소는 자유롭게 사용할 수 있어서 편리하지만, 인터넷상의 호스트 등과 통신이 불가능하다. 즉, 사설 주소만 존재하는 경우 브라우저로 웹사이트를 열람할 수 없다. 이를 해결하기 위해서는 공공 주소와 사설 주소가 모두 할당된 호스트를 준비한다.

#### 라우팅

송신 및 수신 시에 서버 내에서만 처리되는 TCP와 달리 IP는 경로 도중에 다양한 처리가 이루어진다. 그중 하나는 라우팅이다.

IP 주소를 이용해 대상 서버를 지정한다. 하지만 대상 서버가 항상 같은 네트워크 내에 있는 것은 아니다. 다른 네트워크에 있는 경우는 최종 목적지에 도착하는 방법을 알고 있는 라우터에게 전송을 부탁한다.

IP 패킷을 받은 라우터는 해당 IP 패킷의 헤더에서 목적지를 확인해서 어디로 보내야 할지 확인한다. 이때 사용되는 것이 라우팅 테이블이라는 것이다. 서버나 라우터는 자신이 알고 있는 목적지 정보를 라우팅 테이블이라 하는 형태로 목록화한다. 라우팅 테이블은 사람이 직접 입력한 경로 정보나 자신의 서버에 설정된 IP 주소로 파악할 수 있는 정보 등 다양한 정보를 이용해서 구성된다.

외부와 접속하는 네트워크는 보통 기본 게이트웨이라는 라우터가 설치 돼 있다.

만약 A와 B라는 네트워크에 소속된 서버가 IP 패킷을 네트워크 E에 보내려면 외부 네트워크를 찾아야 한다. 본인의 네트워크가 아니기 때문에 A와 B에만 소속된 서버는 기본 게이트웨이로 패킷을 보낸다. 기본 게이트웨이는 외부 네트워크에 접속돼 있어서 외부 세계에 패킷을 보낼 수 있다. 게이트웨이는 외부 네트워크에서 E를 찾아서 제대로 전송을 한다.

자신이 관리하지 않는 네트워크를 이렇게 경유해서 목적지에 도착하게끔 한다. 라우팅 테이블을 기반으로 패킷을 전송하는데, 만약 라우팅 테이블이 잘못 되었다면 목적지가 바뀔 수 있다.
특정 상황에서는 패킷이 몇 번이고 왕복을 하는 경우도 생길 수 있는데, 이런 상태를 방지하기 위해 IP 헤더는 TTL(Time To Live)라는 생존 시간 정보를 가지고 있다. TTL = 64라고 가정해보자. 라우터를 하나 경유할 때마다 TTL -= 1이 되고 TTL이 0이 되는 경우 라우터가 패킷을 파기한다. 정상적으로 전송된 경우 64개의 라우터를 경유할 이유가 없기 때문이다.
TTL 값은 실제로는 OS마다 다르다.

IPv4 헤더에는 헤더 체크섬을 저장하는 장소가 있다. 이를 통해 헤더 정보가 파괴됐는지 여부를 확인할 수 있다. 만약 헤더 정보가 변경된다면 체크섬은 다시 계산되어야 한다. TTL은 라우터를 경유할 때마다 변하기 때문에 매번 체크섬이 다시 계산된다. 이런 경우는 효율이 떨어지게 된다.

어차피 TCP 헤더에도 체크섬이 있기 때문에 IPv6부터는 체크섬이 제외되었다. 또 IPv6 헤더는 40바이트 고정 길이를 사용하는 등 라우터가 처리해야 할 부분을 줄이고 있다.

### [레이어 2] 데이터 링크 계층의 프로토콜 이더넷

IP 패킷이 만들어지면 링크 계층의 처리로 이어진다.
링크 계층에서 사용되는 대표적인 프로토콜은 이더넷이다. 무선 랜을 사용하는 경우 무선 랜 프로토콜을 사용한다.

링크 계층 프로토콜의 역할은 간단히 '동일 네트워크 내의 네트워크 장비까지 전달받은 데이터를 운반한다'고 할 수 있다. TCP/IP 4계층 모델에서는 물리 계층과 함께 하나의 계층으로 취급되듯이, 이더넷이란 링크 계층 프로토콜은 OSI 7계층 모델의 물리 계층과 밀접한 관계가 있다.

이더넷은 케이블 통신에서 사용되기 때문에 이더넷 프레임은 전기 신호로 전송된다. 이 때문에 이더넷 프로토콜에는 전기 신호의 특성과 관련된 제어 기능 등 다양한 기능이 포함돼 있다.

IP는 IP 주소를 사용해서 여러 네트워크를 거쳐 데이터를 전송할 수 있지만, 이더넷은 동일 네트워크 내, 즉 자신이 포함된 링크 내에서만 데이터를 전송할 수 있다. 이때 사용되는 주소가 MAC 주소다.

#### 커널 공간의 이더넷 처리 흐름

IP 계층에서 라우팅 테이블을 확인한 경우 어떤 링크(NIC)가 패킷을 보낼지는 정해져 있다. 최종적인 통신 상태가 동일 네트워크 내에 있으면 해당 서버에 직접 전송하지만, 다른 네트워크에 있으면 기본 게이트웨이에 패킷을 보내야 한다. 여기서는 MAC 주소라 불리는 링크 계층 주소를 사용해서 첫 번째 목적지로 보낸다.

이더넷 헤더에는 이 MAC 주소를 목적지로 기입한다. 단, 여기에 적히는 것은 동일 링크 내에 있는 장비의 MAC 주소다. IP 주소에 라우팅 테이블이 있었던 것처럼 MAC 주소에는 ARP 테이블이라 불리는 표가 있다. 동일 링크 내의 노드에 대해서 'IP 주소 A에 대응하는 것은 MAC 주소 B다'와 같은 형식으로 IP 주소와 MAC 주소의 대응 관계를 기록한 표다. 이렇게 인접한 장비의 MAC 주소를 헤더에 기록한 후 최종적으로는 OS가 버스를 통해 NIC에게 전달한다. NIC는 이것을 다시 네트워크에 전송한다. (IP 패킷에 이더넷 헤더와 푸터를 붙이면 이더넷 프레임이 된다.)

이더넷 등 해당 링크 층에서 하나의 프레임으로 전송할 수 있는 최대 크기를 MTU(Maximum Transfer Unit)라고 한다. 링크 종류나 설정에 따라 달라지지만, 일반적인 이더넷에서는 1500바이트로 설정되어 있다. MTU에서 IP, TCP 헤더 크기를 뺀 것이 TCP에서의 MSS다.

IP 패킷의 최대 크기는 'IP 헤더 + TCP 헤더 + MSS'이지만, 어째서 IP 패킷의 최대 크기를 MSS를 조절해서 맞추는 것일까?

MTU가 크면 MTU보다 작은 IP 패킷을 다룰 때 데이터를 전달하는 통신 횟수가 늘어난다. 버스 한 대에 적은 인원만 여러 번 태워 보내는 것과 같다. 반대로 MTU가 작으면 IP 패킷을 MTU에 맞게 쪼개야 하는데, TCP 계층에서 쪼개고 IP 계층에서도 쪼개는 과정이 비효율적이다. MTU는 네트워크 경로에 따라 바뀔 수 있는데, 경로 도중에 MTU가 작아져서 1패킷이라도 MTU에 들어가지 않으면 패킷이 분할된다. 간혹 설정에 따라 실시되지 않는 경우도 있는데, 이 경우 패킷이 파기된다. 이를 방지하기 위해 송신 측이 'Path MTU Discovery'라는 방법을 이용해서 송신 전에 경로상의 최소 MTU를 조사해서 미리 세그먼트 크기를 조정할 수 있다.

#### 동일 네트워크 내의 데이터 전송

MAC 주소는 IP 주소와 어떻게 다를까? MAC 주소는 네트워크 통신을 하는 하드웨어에 할당된 주소로, 원칙적으로는 세상에 있는 모든 장비가 고유한 물리 주소를 가지고 있다. IPv4 주소는 32비트로 표현했지만, MAC 주소는 48비트로 표현한다. 보통은 16진수로 표기한다.

서버 등이 보낸 이더넷 프레임이 L2 스위치에 도착하면 프레임을 받은 L2 스위치는 MAC 주소를 보면서 적절한 포트에서 프레임을 꺼낸다. 하지만 다른 네트워크(L3 스위치나 라우터)를 거치는 경우는 MAC 주소를 사용한 통신이 불가능하다.

또한, IP를 이용한 브로드캐스트 주소 통신은 이더넷상에서의 브로드캐스트 통신으로 전송된다.물론, 브로드캐스트를 이용한 통신도 다른 네트워크를 거쳐서 전송할 수 없기 때문에 하나의 네트워크를 브로드캐스트 도메인이라고도 부른다.

#### VLAN

네트워크를 구축할 때는 통신이 도달하는 범위를 생각해야 한다. 브로드캐스트 통신 등 전체에 데이터를 전송하는 경우는 불필요한 트래픽을 증가시킨다. 즉, 브로드캐스트 도메인을 고려해서 네트워크를 적절하게 분할하는 것이 필요하다.
네트워크 범위는 네트워크 스위치의 물리 구성에 의해 크게 좌우되기 때문에 유연하게 구성하기가 어렵다. 따라서 물리 구성에 좌우되지 않고 설정만으로 네트워크를 나눌 수 있는 구조가 필요하다.

VLAN은 물리 구성에 의존하지 않고 가상적인 네트워크를 나누는 구조다. 가상적으로 나눈 네트워크는 VLAN ID라 불리는 숫자로 관리한다. VLAN에는 몇 가지 종류가 있지만 자주 사용되는 것은 태그 VLAN이다. 이더넷 프레임에 해당 프레임이 소속된 VLAN ID의 '태그'를 붙여서 하나의 물리 링크 내에서도 복수의 네트워크 이더넷 프레임을 처리할 수 있는 구조다. 이를 통해 하나의 이더넷 케이블 내에서 다른 VLAN에 속하는 프레임을 전송할 수 있게 되어, 물리적으로 떨어져 있는 네트워크 스위치라도 동일 네트워크에 참가시키는 것이 가능하다. 네트워크 스위치의 포트별로 어떤 VLAN ID와 연결할지를 설정해서 하나의 L2 스위치라도 여러 네트워크를 다룰 수 있다.

설령 같은 L2 스위치에 접속된 컴퓨터들이라도 각각 다른 VLAN ID에 설정된 포트를 사용하고 있는 경우는 별도의 L3 스위치나 라우터 없이는 서로 통신할 수 없다.

### TCP/IP를 이용한 통신 이후

#### 네트워크 스위치 중계 처리

OS에서는 커널 내에서 프레임을 처리하고 있지만, L2 스위치도 컴퓨터이기 때문에 내부에는 스위치용 OS가 동작하고 있다. 네트워크 스위치는 OS가 아니라 일반 서버와 달리 프레임이나 패킷 처리에 특화된 ASIC이라 하는 회로를 가지고 있어서 하드웨어 처리만으로 프레임이나 빠르게 패킷을 전송할 수 있다.

L2 스위치나 L3 스위치를 경유해서 최종 목적지인 서버에 이더넷 프레임이 도착한다. NIC로 프레임이 도착하면 일단 NIC 수신 큐에 저장해서 OS 끼어들기나 OS 폴링을 이용해서 커널 내에 프레임을 복사한다. 그리고 이더넷 헤더와 푸터를 제거하고 IP 패킷을 꺼낸다. 여기서 IP 주소를 확인해서 자신에게 보낸 패킷이 맞는지 확인한다. 자신에게 보낸 패킷이 맞다면 IP 헤더를 제거하고 TCP 세그먼트를 꺼낸다.

TCP 포트 번호를 확인해서 포트 번호에 대응하는 소켓에 데이터를 전달한다. TCP는 데이터 보증을 하기 때문에 없어진 세그먼트가 있어서도 안 되고 순서가 틀려서도 안 된다. 이 때문에 데이터 재구성을 위해 필요한 세그먼트가 모두 도착하기까지 버퍼 내에서 기다리는 경우가 있다. 마지막으로 TCP 헤더를 제거하고 안에 있는 애플리케이션 데이터를 재구성하여, 소켓을 통해 애플리케이션에 전달한다.
