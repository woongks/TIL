시스템이 처리하는 데이터와 시스템상에서의 데이터 흐름을 구체적으로 살펴볼 것.

### 3계층형 시스템의 구성도

웹 서버와 AP 서버, DB 서버로 나뉜다.
각 서버는 스위치를 경유해 연결되어 있다.
서버의 논리 구성은 OS에서 이루어진다.

#### 프로세스와 스레드

프로세스와 스레드가 활동하려면 메모리 공간이 필요하다. 커널에 의해 메모리에서 공간이 확보된다. 이 메모리 공간은 다양한 처리를 하면서 데이터를 주고받기 위해 확보된 개인 공간이다.
하나의 프로세스가 동작하고 있으면 내부에서는 메모리 공간을 점유하는 스레드 하나가 동작하고 있다. 각 스레드는 메모리 공간을 공유하고 있다. 스레드 시작 시에 신규 메모리 공간은 필요 없지만 다른 스레드에 이상이 발생하면 영향을 받는다.

프로세스와 스레드 중에 어떤 것을 이용할지는 애플리케이션 개발자가 정한다. 이때 각각의 특성을 이해하고 설계와 프로그래밍할 필요가 있다.
예를 들어, 프로세스는 독자 메모리 공간을 가지기 때문에 생성 시 CPU 부하가 스레드와 비교해 높아진다. 때문에 멀티 프로세스 애플리케이션에서는 프로세스 생성 부담을 낮추기 위해 미리 프로세스를 시작시켜 둔다.

프로세스와 스레드의 장단점
||프로세스|스레드|
|---|---|---|
|장점|개별 처리 독립성이 높다|생성 시 부하가 낮다|
|단점|생성 시 CPU 부하가 높다|메모리 공간을 공유하기 때문에 의도하지 않는 데이터 읽기/쓰기가 발생할 수 있다|

프로세스가 메모리 공간을 공유할 수 없는 것은 아니다.
예를 들어 오라클 DB에서는 여러 프로세스가 공유 메모리 공간을 상호 이용할 수 있게 되어 있다.

#### OS 커널

커널은 OS의 심장과 같다. 커널은 뒤에서 무슨 일이 벌어지는지 은폐하면서도 편리한 인터페이스를 제공하는 역할을 한다.

커널의 역할은 크게 6가지가 있다.

1. 시스템 콜 인터페이스: 프로세스나 스레드로부터 명령을 받음
2. 프로세스 관리: 프로세스 관리와 CPU 이용 우선순위 스케줄
3. 메모리 관리: 메모리를 블록 단위로 분할해서 프로세스에 할당
4. 네트워크 스택: 네트워크 관리
5. 파일 시스템 관리
6. 장치 드라이버: 디스크, NIC, HBA 등의 물리 장치와 작업

시스템 콜 인터페이스

> 프로세스/스레드에서 커널로 연결되는 인터페이스다. 애플리케이션이 OS를 통해서 어떤 처리를 하고 싶으면 시스템 콜이라고 하는 명령을 이용해서 커널에 명령을 내린다. 이때 명령이 인터페이스를 통해서 전달된다. (디스크 I/O와 네트워크 I/O 모두 시스템 콜이다)

프로세스 관리

> OS상에서는 수십, 수백, 수천 개의 프로세스를 가동할 수 있다. 이에 비해 물리 서버의 CPU 코어 수는 많아야 수십 개 정도밖에 안 된다. 언제 어떤 프로세스가 어느 정도의 CPU 코어를 이용할 수 있는지, 처리 우선순위를 어떻게 결정할 것인지 등을 관리하는 것이 이 기능의 역할이다.

메모리 관리

> 프로세스 관리는 CPU 코어를 고려했지만, 메모리 관리에서는 물리 메모리 공간의 최대치를 고려한다. 프로세스가 이용하는 독립 메모리 공간을 확보하거나 상호 간의 참조 영역을 지키기 위해 독립성을 관리하는 등의 메모리 관리 역할을 한다.

파일 시스템 관리

> 파일 시스템용 인터페이스를 제공한다. 0과 1의 숫자 집합에 파일이라는 단위로 데이터를 작성하거나 삭제할 수 있게 한다.

장치 드라이버

> 디스크나 NIC 등의 물리 장치용 인터페이스를 제공한다. 예를 들어, NIC나 디스크는 다수의 제조사가 독자 제품을 제공하고 있다. 각각에 대응하는 애플리케이션을 개발하는 것은 현실적이지 못하기 때문에 커널은 장치 드라이버를 이용해서 그 아래에 있는 물리 장치를 은폐한다. 각 장치 제조사가 OS에 대응하는 장치 드라이버를 제공해서 해당 OS의 표준 장치로서 커널을 경유해 이용할 수 있게 한다.

커널 설계 및 구현 방식에는 모노리식과 마이크로가 있다. 모노리식 커널은 OS의 주요 구성 요소를 모두 하나의 메모리 공간을 통해 제공한다. 마이크로 커널은 최소한의 기능만 커널이 제공하고 그 외 기능은 커널 밖에서 제공한다.

### 웹 데이터 흐름

#### 클라이언트 PC부터 웹 서버까지

클라이언트 PC에서 웹 브라우저를 실행해서 웹 서버에 요청을 보내고 AP 서버에 질의하기까지의 흐름을 아는 것은 중요하다.

전체 흐름은 다음과 같다.

1. 웹 브라우저가 요청을 발행한다.
2. 이름 해석을 한다.
3. 웹 서버가 요청을 접수한다.
4. 웹 서버가 정적 콘텐츠인지 동적 콘텐츠인지 판단한다.
5. 필요한 경로로 데이터에 액세스한다.

웹 서버에는 HTTP를 처리할 수 있는 'httpd 프로세스'가 가동되고 있다. 아파치에서는 기본적으로 부모 프로세스와 자식 프로세스로 나누어 처리를 분담하고 있다.

요청에 대한 대답 내용은 HTML 파일이라는 텍스트 데이터나 이미지, 동영상 등의 바이너리 데이터로 구성된다. 이 데이터들은 '정적 콘텐츠'와 '동적 콘텐츠'로 분류할 수 있다.
'정적 콘텐츠'란 실시간으로 변경할 필요가 없는 데이터를 가리킨다.
'동적 콘텐츠'란 높은 빈도로 변경되는 데이터를 가리킨다.
동적 콘텐츠는 서버 내부의 디스크에 저장하면 갱신 빈도가 높아 디스크 성능이 병목 현상의 원인이 될 수 있다. 또한, 파일이라는 형태로 저장하는 것 자체가 비효율적일 수 있다. 일반적으로 이런 동적 콘텐츠는 'AP 서버'가 HTML 파일을 동적으로 생성한다. 웹 서버는 동적 콘텐츠에 대한 요청을 AP 서버에 던지고 결과를 기다린다.

#### 웹 서버부터 AP 서버까지

'동적 콘텐츠'에 대한 요청을 처리하는 것이 AP 서버다.

1. 웹 서버로부터 요청이 도착한다.
2. 스레드가 요청을 받으면 자신이 계산할 수 있는지, 아니면 DB 접속이 필요한지를 판단한다.
3. DB 접속이 필요하면 연결 풀에 액세스한다.
4. DB 서버에 요청을 던진다.

웹 서버에서 온 요청은 NIC를 경유해서 커널에 의해 끼어들기 처리된다.
스레드가 요청을 접수한다.
동적 데이터를 가져오기 위해 연결 풀을 이용하여 DB에 접속한다.
DB에 보내는 접속 요청도 물론 시스템 콜을 이용한다.
네트워크 경유로 DB 서버에 대한 질의가 이루어진다.

대량의 데이터는 AP서버가 감당할 수 없고 DB서버에 저장한다.
데이터는 AP서버가 DB서버에 질의를 하고 그 결과를 HTML 등으로 정리해서 반환한다. AP서버가 DB서버에 접속하려면 '드라이버'가 필요하다. 장치 드라이버와 비슷하다. 드라이버 뒷단에 있는 것이 데이터베이스로 가는 인터페이스로, 해당 데이터베이스 자체를 은폐하는 역할을 한다.

DB서버 이외의 옵션?

> 데이터가 필요하면 DB 서버에 접속하는 것이 일반적이지만, 이것이 항상 효율적이라고 할 수는 없다. 규모가 작고 갱신 빈도가 낮은 정보는 캐시로 저장해 두었다가 변환하는 것이 좋다.

> 반대로 규모가 큰 정적 데이터 전송 시에는 DB서버 이외에 CDN이라 불리는 데이터 전송 전용 서버를 이용하는 경우도 있다.

#### AP서버부터 DB서버까지

DB서버가 요청을 접수하는데, 이때 언어는 SQL이다. SQL을 해석해서 데이터 액세스 방식을 결정하고, 디스크나 메모리에서 필요한 데이터만 수집해 오는 것이 데이터베이스의 주요 역할이다.

전체적인 흐름은 다음과 같다.

1. AP서버로부터 요청이 도착한다.
2. 프로세스가 요청을 접수하고 캐시가 존재하는지 확인한다.
3. 캐시에 없으면 디스크에 액세스 한다.
4. 디스크가 데이터를 반환한다.
5. 데이터를 캐시 형태로 저장한다.
6. 결과를 AP서버에 반환한다.

DB서버에도 다양한 소프트웨어가 존재한다. 웹 계열 시스템에서는 MySQL이나PostgreSQL 등이 인기 있다.
기업용으로는 오라클이 많이 쓰인다.

DB서버는 데이터 저장 창고다. 관리 대상 데이터가 방대하기 때문에 얼마나 효율적으로 액세스하는가가 중요하다. 대부분은 서버 메모리에 캐시가 있는지 먼저 확인한다. 없으면 디스크에 액세스해서 필요한 데이터를 가지고 온다.

인메모리 DB는 디스크 자체를 사용하지 않고 모든 처리를 메모리 내에서 완료하는 구조라서 고속화를 실현할 수 있다.

DB 서버에서는 여러 개의 프로세스가 역할을 분담하는 경우가 있다.
예를 들어, 오라클 DB에서는 공유 메모리 밑에 여러 프로세스들이 있다. SQL 요청을 받아서 데이터를 검색, 가공하는 서버 프로세스, LGWR 프로세스, DBWR 프로세스 등이 있다.

DB 서버로는 보통 서버 내부의 디스크보다는 외부의 저장 장치를 사용한다. 내부 디스크는 이중화 관점에서 뒤떨어지기 때문이다. 외부 저장소는 대량의 데이터에 고속 액세스하기 위한 전용 서버라고 생각하면 된다.

RDBMS는 표로 데이터를 표현하기 때문에 필연적으로 데이터가 정리된다. 그리고 릴레이션에 의해 표 사이의 관계를 표현하는 것도 특징이다. 데이터의 일관성을 더 엄격히 관리하기 때문에 다른 방식보다 갱신 속도가 느린 경향이 있다.

#### AP 서버부터 웹 서버까지

DB 서버에서 데이터가 돌아왔기 때문에 AP 서버의 요청 스레드로 결과가 반환된다. 데이터를 집계하는 등 요청 내용을 바탕으로 가공한 후에 웹서버로 데이터를 반환한다.

전체 흐름은 다음과 같다.
1. DB 서버로부터 데이터가 도착한다.
2. 스레드가 데이터를 가지고 계산 등을 한 후에 파일 데이터를 생성한다.
3. 결과를 웹 서버로 반환한다.

#### 웹 서버부터 클라이언트 PC까지

AP 서버에서 돌아온 데이터를 받아서 웹 서버의 httpd 프로세스가 PC의 웹 브라우저로 반환한다.

전체 흐름은 다음과 같다.
1. AP서버로부터 데이터가 도착한다.
2. 프로세스는 받은 데이터를 그대로 반환한다.
3. 결과가 웹 브라우저로 반환되고 화면에 표시된다.

#### 웹 데이터의 흐름 정리

각 서버의 동작은 다르지만 다음과 같은 공통점이 있다.
- 프로세스나 스레드가 요청을 받는다.
- 도착한 요청을 파악해서 필요에 따라 별도 서버로 요청을 보낸다.
- 도착한 요청에 대해 응답한다.

3계층 시스템에서는 사용자 요청에서 시작해 요청이 다양한 서버로 전달된다. 특징으로는 자신이 할 수 없는 처리는 다음 서버에 그 역할을 떠넘긴다는 것이다. 3계층이라고 명명하지만 실제로는 3계층보다 많은 계층을 이용하는 경우가 대부분이다.

요청 기반 아키텍처이기 때문에 기본적으로 각 서버는 '문을 열고 기다리고 있는' 상태다. 어느 정도 요청이 올지는 실제 요청이 오기 전까지는 알 수 없다.
IT 인프라에서 성능 문제가 발생하는 이유 중 하나다.

### 가상화

#### 가상화란?

온프레미스에서 가상화 기술을 사용하는 경우가 많다. 대량의 컴퓨터를 다루는 클라우드 환경은 가상화 기술을 기반으로 구축된다. 

가상화란, 컴퓨터 시스템에서 물리 리소스를 추상화하는 것이다. ( 가상이라는 용어는 물리적으로 존재하지 않지만 실제로 존재하는 것과 같다는 의미를 떠올리는 것이 이해하기 쉽다.)

#### OS도 가상화 기술의 하나

하드웨어를 의식하지 않고 애플리케이션을 실행할 수 있는 운영체제는 가상화 기술 중 하나라고 볼 수 있다.
OS 커널에 의해 하드웨어가 추상화되면서, 컴퓨터에 연결된 기억 장치나 네트워크를 통한 데이터 교환이 하드웨어를 의식하지 않고 이루어지고 있다.

#### 가상 머신

가상 머신 방식에는 호스트 OS형과 하이퍼바이저형이 있다. 호스트 OS형은 윈도우나 리눅스 등의 호스트 OS상에 가상화 소프트웨어를 설치해서 이용하는 것으로, VMware Server, Microsoft Virtual Server 등이 있다. 소프트웨어를 에뮬레이터하는 것으로 성능면에서 제한이 있다. 그래서 등장한 것이 하이퍼바이저형이다. VMware vSphere, Hyper-V, Xen, KVM 등이 이에 속한다.
하이퍼바이저형은 하드웨어상에서 직접 가상화 소프트웨어를 실행하고 그 위에 가상 머신을 동작시키는 기술이다. 호스트 OS를 거치지 않으므로 호스트형보다 성능이 우수해서 서버 가상화의 대표 기술로 자리 잡았다.

하이퍼바이저형 가상화 구조에는 완전 가상화와 준가상화가 있다. 완전 가상화는 물리 머신상에서 동작하는 OS나 드라이버를 그대로 게스트로 이용할 수 있는 장점이 있지만 소프트웨어로 에뮬레이션하기 때문에 성능이 저하된다는 문제가 있다. 이 문제를 해결하기 위해 등장한 것이 준가상화다. 실존하는 하드웨어를 에뮬레이션하는 것이 아니라, 가상 환경용 가상 하드웨어를 소프트웨어적으로 에뮬레이션한다. 준가상화에선 가상 환경에서 동작시키는 게스트 OS마다 준가상화 전용 드라이버나 준가상화용으로 최적화된 OS커널을 이용해야 했었다. 이후로 프로세서 제조사가 가상 하드웨어 지원 기능을 개발해서 하이퍼바이저도 지원하게 되면서 현재는 완전 가상화가 자리를 잡았다.

#### 컨테이너의 역사

도커의 등장 이후 컨테이너가 큽속도로 유행하기 시작했다. 컨테이너는 한 마디로 정의하면 '리소스가 격리된 프로세스'다. 하나의 OS상에서 여러 개를 동시에 가동할 수 있으며, 각각 독립된 루트 파일 시스템, CPU/메모리, 프로세스 공간 등을 사용할 수 있다는 점이 하드웨어 가상화인 가상 머신(VM)과의 차이다. 각 컨테이너는 커널 공간을 공유한다.

컨테이너의 시발점인 chroot의 기능은 프로세스가 OS의 루트 디렉터리 아래에 있는 특정 계층에 접근하지 못하게 하는 기능을 갖고 있다. 1990년대에 FreeBSD jail이 등장해서 특정 디렉터리 이하를 루트 디렉터리처럼 보이게 하는 chroot 개념이 추가됐고 이를 통해 애플리케이션의 프로세스도 격리할 수 있게 됐다.

#### 도커의 등장

상용 유닉스나 오픈 소스에서 컨테이너 기술의 개발이 착실히 진행됐고 2013년에 파일 시스템과 프로세스를 분리하는 기능이 추가됐다. 이를 통해 파일 시스템 이미지의 패키징과 버저닝이 가능해졌고 컨테이너 이미지를 공유할 수 있는 도커가 등장함으로써 컨테이너 기술이 주목을 받기 시작했다.

도커 회사는 개명하기 전에 닷클라우드라는 명칭을 사용했고 2008년 언어에 의존하지 않는 PaaS를 구축하기 위해 설립됐다. PaaS는 개발한 애플리케이션을 클라우드에 배포해서 실행하는 구조였다. 하지만 애플리케이션 관련 프레임워크나 라이브러리 등의 버전이 일치하지 않아서 로컬에서 실행된 프로그램이 크라우드에서는 실행되지 않는 문제가 빈번하게 발생했다.
따라서 원래 클라우드 내부 구조로 개발했던 애플리케이션 실행 환경을 자동 구축해주는 '도커 이미지'라는 기술을 클라우드 이외의 환경에서도 사용할 수 있게 오픈 소스로 공개했다.

가상 머신과 비교해서 도커가 지니는 장점은 다음과 같다.
- 컨테이너는 호스트 OS와 OS 커널을 공유하므로 컨테이너 실행이나 정지 속도가 빠르다.
- 호스트 OS의 커널을 공유하므로 VM만 사용하는 경우와 비교해 한 대의 호스트 머신상에서 훨씬 많은 컨테이너를 실행할 수 있따. 이를 통해 리소스를 한 곳에서 쉽게 관리할 수 있다.
- 도커는 라이브러리나 프레임워크 등을 도커 이미지로 묶어서 공유할 수 있는 것으로, 특정 환경에서는 재현되지만 자신의 개발 환경에서는 재현되지 않는 문제가 발생하기 어렵다. 따라서 버그를 효율적으로 수정할 수 있다.

#### 클라우드와 가상화 기술

하이퍼바이저 및 컨테이너 등의 가상화 기술은 구글이나 페이스북, 아마존 등의 대규모 웹 서비스에서 사용되고 있다. AWS 등의 클라우드 서비스에는 가상 머신 서비스, 컨테이너 서비스, FaaS 서비스나 다른 기타 서비스를 지탱하는 기술로 이용되고 있다.