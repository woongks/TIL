### 유니캐스트, 멀티캐스트, 브로드캐스트, 애니캐스트

네트워크에서 출발지에서 목적지로 데이터를 전송할 때 사용하는 통신 방식이다. 각 통신 방식은 다음과 같다.
1. 유니캐스트
> 출발지와 목적지가 1:1로 통신
2. 브로드캐스트
> 하나의 호스트에서 시작해 동일 네트워크에 존재하는 모든 호스트가 목적지
3. 멀티캐스트
> 하나의 출발지에서 다수의 특정 목적지로 데이터 전송
4. 애니캐스트
> 1:1 통신인데 동일 그룹 내 가장 가까운 호스트에서 응답.

대부분의 통신은 출발지와 목적지가 정해져 있는 유니캐스트 방식이다.

브로드캐스트의 경우 목적지 주소가 모든으로 표기되어 있는 통신 방식이다. 보통 유니캐스트로 통신하기 전 상대방의 정확한 위치를 알기 위해 사용된다.

멀티캐스트는 멀티캐스트 그룹 주소를 이용해 해당 그룹에 속한 다수의 호스트로 패킷을 전송하기 위한 통신 방식이다. IPTV와 같은 실시간 방송을 볼 때 이 멀티캐스트 통신 방식을 사용한다. 사내 방송이나 증권 시세 전송과 같이 단방향으로 다수에게 동시에 같은 내용을 전달해야 할 때 사용된다.

애니캐스트는 특유의 성질을 이용해서 가장 가까운 DNS 서버나 게이트웨이를 찾는 기능에 사용하기도 한다. 

BUM 트래픽
> Broadcast, Unknown Unicast, Multicast를 지칭한다.
언노운 유니캐스트는 유니캐스트여서 목적지 주소는 명확히 명시되어 있지만 네트워크에서의 동작은 브로드캐스트와 같을 때를 가리킨다. 스위치가 목적지에 대한 주소를 학습하지 못한 상황이라 패킷을 모든 포트로 플러딩하는 경우를 말한다. 이처럼 다수에 보내는 기능은 네트워크 입장에서 자원을 쓸데없이 사용하는 것이기 때문에 불필요한 BUM 트래픽이 많아지면 네트워크 성능이 저하될 수 있다.
(이더넷 환경에서는 ARP 브로드캐스트를 먼저 보내고 이후 통신을 시작하므로 BUM 트래픽이 많이 발생하지 않는다.)

### MAC 주소

Media Access Control의 줄임말로 2계층에서 통신을 위해 네트워크 인터페이스에 할당된 고유 식별자이다. 네트워크에 접속하는 모든 장비는 MAC 주소라는 물리적인 주소가 있어야 하고 이 주소를 이용해 서로 통신한다.

#### MAC 주소 체계

MAC 주소는 하드웨어에 고정되어 출하되므로 네트워크 구성 요소마다 다른 주소를 갖고 있다.
네트워크 장비 제조업체에 주소 풀을 할당하는 것을 제조사 코드라고 부르며 이 주소는 IEEE가 관리한다.

MAC 주소는 48비트이며 앞 24비트는 제조사 코드이며 OUI(Organizational Unique Identifier) 값이라 부른다.

뒤의 24비트인 UAA(Universally Administered Address)는 각 제조사에서 자체적으로 할당한다. 

MAC 주소는 BIA(Burned-In Address)라고도 불린다.
MAC 주소는 BIA 상태로 NIC에 할당되어 있다. 일반적으로 ROM 형태로 고정되어 출하되므로 NIC에 고정된 MAC 주소를 변경하기는 어렵다. 하지만 결국 MAC 주소도 메모리에 적재되어 구동되므로 여러 가지 방법을 이용해 변경된 MAC 주소로 NIC을 동작시킬 수 있다.

#### MAC 주소 동작

NIC은 자신의 MAC 주소를 가지고 있고 전기 신호가 들어오면 2계층에서 데이터 형태로 변환하여 내용을 구분한 후 도착지 MAC 주소를 확인한다. 해당 주소가 자신의 주소와 다르면 그 패킷을 폐기한다. 그게 아니면 처리해야 할 주소로 인지해 패킷 정보를 상위 계층으로 넘겨준다.

패킷이 정상적으로 NIC를 통과하면 OS나 애플리케이션 레벨에서 처리되기 때문에 시스템에 부하가 작용한다.

무차별 모드(promiscuous mode)

네트워크 상태를 모니터링하거나 디버그, 분석 용도로 네트워크 전체 패킷을 수집해 분석해야 할 경우, NIC이 정상적으로 동작하면 다른 목적지를 가진 패킷을 폐기하기 때문에 분석할 수 없다. 이런 경우, 무차별 모드로 NIC을 구성한다. 무차별 모드는 자신의 MAC 주소와 상관없는 패킷이 들어와도 이를 분석할 수 있도록 메모리에 올려 처리할 수 있게 한다. 대표적인 애플리케이션은 와이어샤크가 있다.

### IP 주소

OSI 7계층에서 주소를 갖는 계층은 2계층과 3계층이다. 2계층은 물리 주소인 MAC 주소를 사용하고 3계층은 논리 주소인 IP 주소를 사용한다.

흔히 사용하는 IP 주소는 32비트인 IPv4 주소다. IP 주소는 네트워크와 호스트 주소로 나뉜다. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 한다. 호스트 주소는 동일 네트워크 내에 존재하는 호스트를 구분하기 위함이다.

MAC 주소는 24비트씩 절반으로 구분되지만, IP 주소는 고정되어 있지 않다. IP 주소 체계는 필요한 호스트 IP 개수에 따라 네트워크 크기를 다르게 할당할 수 있는 클래스 개념을 도입했다. A 클래스는 1600만 개, B 클래스는 6만 5천 개, C 클래스는 약 250 개의 IP 주소를 가질 수 있다. A 클래스는 첫 번째 옥텟에, B는 두 번째, C는 세 번째 옥텟에 구분자가 있고 이 구분자를 서브넷 마스크라고 한다.
클래스 개념은 다른 고정된 네트워크 주소 체계에 비해 주소를 절약할 수 있다는 장점이 있다.

#### 클래스풀과 클래스리스

IP 주소 체계에서 설명한 클래스 기반의 IP 주소 체계를 클래스풀(Classful)이라고 부른다. IP 주소 체계를 처음 만들었을 때는 클래스 개념을 도입한 것이 확장성이 있고 주소 낭비가 적은 최적의 조건을 만들 수 있었던 좋은 선택이었다. 이 주소 체계에서는 네트워크 주소와 호스트 주소를 구분짓는 구분자(서브넷 마스크)가 필요없다.

인터넷이 상용화되면서 연결되는 호스트 숫자가 폭발적으로 증가했다. 기존 클래스풀 기반의 주소 체계는 확장성과 효율성을 모두 잡는 좋은 주소 체계였지만 기하급수적으로 늘어나는 IP 주소 요구를 감당하기에는 너무 부족했다. IP 주소 부족과 낭비 문제를 해결하기 위해 3가지 보존, 전환전략을 만들어냈는데 그 중 첫 번째 단기 대책은 클래스리스, CIDR(Classless Inter-Domain Routing) 기반의 주소 체계였다. 두 번째 중기 대책은 NAT와 사설 IP 주소, 세 번째 장기 대책은 차세대 IP인 IPv6이다.

IPv4의 가장 큰 문제는 주소 자체의 부족도 있지만 상위 클래스(A Class)를 할당받은 조직에서 이 주소들을 제대로 사용하지 못하면서 낭비하는 것이었다. 이 문제를 해결하기 위해 클래스 개념 자체를 버리는데, 이를 클래스리스라고 부른다. 현재 사용하는 주소 체계는 클래스 개념을 적용하지 않는 클래스리스 기반 주소 체계다. 클래스리스 네트워크에서는 별도로 네트워크와 호스트 주소를 나누는 구분자를 사용해야 하는데 이 구분자를 서브넷 마스크라고 부른다.

서브넷 마스크는 IP 주소와 네트워크 주소를 구분할 때 사용한다. 숫자 1을 네트워크 주소, 0은 호스트 주소로 표시한다. 보통 10진수를 사용해 255.0.0.0, 255.255.255.0과 같이 표현한다. 

만약 103.9.32.146 주소에 255.255.255.0 서브넷 마스크를 사용하는 IP는 네트워크 주소가 103.9.32.0이고 호스트 주소는 0.0.0.146이 된다. 

서브넷 마스크 표현 방법은 비트 단위로 표현하는 방법도 존재한다. /8, /16, /24로 표기한다.

#### 서브네팅

원래 부여된 클래스의 기준을 무시하고 새로운 네트워크-호스트 구분 기준을 사용자가 정해 원래 클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것을 서브네팅이라고 한다. 서브네팅은 현대 클래스리스 네트워크의 가장 큰 특징이다. 옥텟 단위로 구분되는 서브네팅은 이해와 운영이 쉽지만 실제로는 옥텟 단위보다 더 잘게 네트워크를 쪼개 2진수의 1비트 단위로 네트워크를 분할하므로 서브네팅을 이해하기 어렵다.

실무에서 서브네팅에 대해 고민해야 하는 경우는 두 가지다. 네트워크 디자인 단계에서 네트워크 설계자가 네트워크를 효율적으로 어떻게 분할할 것인지 계획하는 경우와 이미 분할된 네트워크에서 사용자가 자신의 네트워크와 원격지 네트워크를 구분해야 하는 경우다. 상황에 따라 고려해야 할 요소와 범위가 달라진다.

- 네트워크 사용자 입장
> 네트워크에서 사용할 수 있는 IP 범위 파악  
기본 게이트웨이와 서브넷 마스크 설정이 제대로 되어 있는지 확인
- 네트워크 설계자 입장
> 네트워크 설계 시 네트워크 내에 필요한 단말을 고려한 네트워크 범위 설계

#### 네트워크 사용자의 서브네팅

네트워크 사용자는 이미 설계되어 있는 네트워크에서 사용할 수 있는 IP 주소 범위를 파악해야 한다. 주어진 네트워크 범위 밖의 IP를 할당하거나 서브넷 마스크를 잘못 입력하면 로컬 네트워크의 특정 범위에 속해있는 단말과 통신에 문제가 생기거나 외부 네트워크 전체에 통신하지 못하는 상황이 발생한다. 기존 클래스 단위처럼 옥텟 단위의 네트워크를 사용할 경우, 모든 수가 10진수 단위로 표현되므로 관리자나 사용자가 이해하기 쉽지만, 대부분의 서브네팅은 비트 단위로 불할되므로 이런 환경에 속해 있을 경우, 어떤 IP 범위가 내가 속한 네트워크이고 어떤 IP 범위가 원격지 네트워크인지 판단하기 어렵다.

#### 네트워크 설계자의 서브네팅

네트워크를 새로 구축하는 경우, 네트워크 사용자와 반대로 설계자는 서브넷 마스크가 지정되어 주어지는 것이 아니라 네트워크의 크기를 고민해 서브넷 마스크를 결정하고 설계에 반영해야 한다. 네트워크 설계자가 IP를 설계할 때 고민해야 할 부분은 다음과 같다.
- 서브넷된 하나의 네트워크에 IP를 몇 개나 할당해야 하는가?
- 서브넷된 네트워크가 몇 개나 필요한가?

네트워크를 설계할 때 가능하면 사설 IP 대역을 사용해 충분한 IP 대역을 사용하는 것이 좋다. 

공인 IP를 사용해 여유 없이 네트워크를 할당하면 크기가 다른 네트워크가 많아진다. 따라서 사설로 최대한 같은 크기의 네트워크를 할당하고 10진수로 표현해도 쉽게 이해할 수 있는 C 클래스 단위인 24비트로 쪼개 할당하는 것이 바람직하다.

#### 공인 IP와 사설 IP

인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 공인 IP 주소를 할당받지 않고도 네트워크를 구축할 수 있다.
이때 사용하는 IP 주소를 사설 IP 주소라고 한다. 외부 인터넷과 연결하려면 공인 IP 주소를 할당받거나 사설 IP를 이용하되 NAT 기술을 사용해야 한다. 
인터넷 표준은 RFC(Request for Comments)와 그 집합을 가리킨다.  RFC의 원래 의미는 비평을 기다리는 문서로,
RFC 자체가 인터넷 표준 문서는 아니며 컴퓨터, 인터넷 기술에 적용할 수 있는 제안, 조사 결과, 아이디어, 표준 등을
적어놓은 메모 형식의 문서 모음이다. RFC 문서 중 의미가 있는 표준 문서는 국제 인터넷 표준화 기구(IETF)를
통해 표준으로 인정받는다.

사설 IP를 설정할 때, 실제로 어딘가에 존재하는 공인 IP를 사설 IP로 사용하면 안된다. 아무리 NAT가 있더라도
공인 IP로 인식을 하기 전에 사설 IP를 먼저 보기 때문에 해당 IP를 가진 외부 서버에는 접속할 수 없게 되기 때문이다.

Bogon IP?

> IP 주소를 할당하는 최상위 기구인 IANA가 여러 가지 목적으로 예약해놓아 공인 IP로 할당하지 않는 주소를
Bogon IP라고 한다. 이 Bogon IP는 인터넷에서 동작하는 라우터에 해당 IP 정보가 존재하지 않는다.
만약 Bogon IP 대역의 주소를 사용한 통신 시도가 있었다면 해킹을 목적으로 IP를 스푸핑했거나 실수로 할당된
IP를 사용한 경우이므로 필터링하는 것이 좋다. 하지만 Bogon IP가 새로 할당되는 경우도 있으니 대역이 변경되는
것을 확인해야 한다.


### TCP와 UDP

2계층과 3계층은 목적지를 정확히 찾아가기 위한 주소 제공이 목적이었지만, 4계층에서 동작하는 프로토콜은
만들어진 목적이 조금 다르다. 목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지
프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내기 위한 역할을 한다.

### 4계층 프로토콜(TCP, UDP)과 서비스 포트

헤더에서 가장 중요한 두 가지 정보는 각 계층에서 정의하는 정보와 상위 프로토콜 지시자 정보다. 각 계층을
정의하는 정보는 수식 측의 동일 계층에서 사용하기 위한 정보다. 상위 프로토콜 지시자는 디캡슐레이션 과정에서
상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용된다. 2계층은 이더 타입, 3계층은
프로토콜 번호, 4계층은 포트 번호가 상위 프로토콜 지시자다.

TCP/IP 프로토콜 스택에서 4계층은 TCP와 UDP가 담당한다. 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고
데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 역할이다.

패킷을 분할하고 조합하기 위해 TCP 프로토콜에서는 시퀀스 번호와 ACK 번호를 사용한다.

TCP/IP 프로토콜 스택에서 4계층의 상위 프로토콜 지시자는 포트 번호다. 일반적으로 TCP/IP에서는 클라이언트-서버
방식으로 서비스를 제공하고 클라이언트용 프로그램과 서버용 프로그램을 구분해 개발한다. 3계층의 프로토콜 번호나
2계층의 이더 타입과 같은 상위 프로토콜 지시자는 출발지와 도착지를 구분해 사용하지 않고 한 개만 사용하지만
4계층 프로토콜 지시자인 포트 번호는 출발지와 목적지를 구분해 처리해야 한다.

포트와 프로토콜 주소 번호를 OS 내부 파일에서 찾아볼 수 있다 (System32\drivers\etc 폴더의 protocols, services)

### TCP

TCP 프로토콜은 패킷에 번호를 부여하고 잘 전송되었는지에 대해 응답한다. 또한, 한꺼번에 얼마나 보내야
수신자가 잘 받아 처리할 수 있는지 전송 크기(Window Size)까지 고려해 통신한다. TCP의 여러 역할 덕분에
네트워크 상태를 심각하게 고려하지 않고 특별한 개발 없이도 쉽고 안전하게 네트워크를 사용할 수 있다.
패킷에 순서를 부여하는 것을 시퀀스 번호, 응답 번호를 부여하는 것을 ACK 번호라고 부른다. 두 번호가
상호작용해 순서가 바뀌거나 중간에 패킷이 손실된 것을 파악할 수 있다.

윈도 사이즈와 슬라이딩 윈도

> TCP는 일방적으로 패킷을 보내는 것이 아니라 상대방이 얼마나 잘 받았는지 확인하기 위해 ACK 번호를 확인하고
전송한다. 패킷이 잘 전송되었는지 확인하기 위해 별도 패킷을 받는 것 자체가 통신 시간을 늘리지만 송신자와
수신자가 먼 거리에 떨어져 있으면 왕복 지연시간(RTT)이 늘어나므로 응답을 기다리는 시간이 더 길어진다.
작은 패킷을 하나 보내고 응답을 받아야만 하나를 더 보낼 수 있다면 모든 데이터를 전송하는 데 긴 시간이
걸릴 것이다. 그래서 데이터를 보낼 때 패킷을 하나만 보내는 것이 아니라 많은 패킷을 한꺼번에 보내고 응답을
하나만 받는다. 가능하면 최대한 많은 패킷을 한꺼번에 보내는 것이 효율적이지만 네트워크 상태가 안 좋으면
패킷 유실 가능성이 커지므로 적절한 송신량을 결정해야 한다. 이때, 한 번데 데이터를 받을 수 있는 크기를 윈도
사이즈라고 하고 네트워크 상황에 따라 이 윈도 사이즈를 조절하는 것을 슬라이딩 윈도라고 한다.


TCP 헤더에서 윈도 사이즈로 표현할 수 있는 최대 크기는 2^16이다. 실제로 64K만큼 윈도 사이즈를 가질 수 있지만
이 사이즈는 회선의 안정성이 높아지고 고속화되는 현대 네트워크에서는 너무 작은 숫자다. 따라서 TCP 헤더를
변경하는 것을 떠나서 헤더 뒤의 숫자를 무시하는 방법으로 윈도 사이즈를 증가시켜 통신한다.

TCP는 데이터에 유실이 발생하면 윈도 사이즈를 절반으로 떨어뜨리고 정산적인 통신이 되는 경우 서서히 하나씩
늘린다. 네트워크에 경합이 발생해 패킷 드롭이 생기면 작아진 윈도 사이즈로 인해 데이터 통신 속도가 느려져
회선을 제대로 사용하지 못하는 상황이 발생할 수 있다. 따라서 회선 속도를 증가시키거나 버퍼가 큰 네트워크
장비를 사용하거나 TCP 최적화 솔루션을 사용해 경합을 최대한 피해야 한다.

TCP에서는 유실없는 안전한 통신을 위해 통신 시작 전, 사전 연결작업을 진행한다. 목적지가 데이터를 받을 준비가
안 된 상황에서 데이터를 일방적으로 전송하면 목적지에서는 데이터를 정상적으로 처리할 수 없어 데이터가
버려진다. TCP 프로토콜은 이런 상황을 만들지 않기 위해 통신 전, 데이터를 안전하게 보내고 받을 수 있는지
미리 확인하는 작업을 거친다. TCP에서는 3번의 패킷을 주고받으며 통신을 서로 준비한다. 이를 3방향 핸드셰이크
라고 부른다.

TCP는 3방향 핸드셰이크 진행 상황에 따라 상태정보를 부르는 이름이 다르다. 서버에는 서비스를 제공하기 위해
클라이언트의 접속을 받아들일 수 있는 LISTEN 상태로 대기한다. 클라이언트에서 통신을 시도할 때 Syn 패킷을
보내는데 클라이언트에서는 이 상태를 SYN-SENT라고 부른다. 클라이언트의 Syn을 받은 서버는 SYN-RECEIVE 상태로
변경되고 Syn, Ack로 응답한다. 이 응답을 받은 클라이언트는 ESTABLISHED 상태로 변경하고 그에 대한 응답을
서버로 다시 보낸다. 서버에서도 클라이언트의 이 응답을 받고 ESTABLISHED 상태로 변경된다. ESTABLISHED 상태는
서버와 클라이언트 간의 연결이 성공적으로 완료되었음을 나타낸다.

TCP 플래그는 총 6가지가 있고 통신의 성질을 나타낸다. 초기 연결, 응답, 정상 종료, 비정상 종료 등의 용도로
사용된다.

- SYN
연결 시작 용도로 사용한다. 연결이 시작될 때 SYN 플래그에 1로 표시해 보낸다.
- ACK
ACK 번호가 유효할 경우, 1로 표시해 보낸다.
- FIN
연결 종료 시 1로 표시된다. 데이터 전송을 마친 후 정상적으로 양방향 정료 시 사용된다.
- RST
연결 종료 시 1로 표시된다. 연결 강제 종료를 위해 연결을 일방적으로 끊을 때 사용된다.
- URG
긴급 데이터인 경우, 1로 표시해 보낸다.
- PSH
서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 것을 지시할 때
사용한다.

### UDP

UDP는 4계층 프로토콜이 가져야 할 특징이 거의 없다. UDP는 데이터 전송을 보장하지 않는 프로토콜이며
제한된 용도로만 사용된다.

UDP는 음성 데이터나 실시간 스트리밍과 같이 시간에 민감한 프로토콜이나 애플리케이션을 사용하는 경우나
사내 방송이나 증권 시세 데이터 전송에 사용되는 멀티캐스트처럼 단방향으로 다수의 단말과 통신해
응답을 받기 어려운 환경에서 주로 사용된다. 데이터를 전송하는 데 신뢰성보다 일부 데이터가 유실되더라도
시간에 맞추어 계속 전송하는 것이 중요한 화상회의 시스템과 같은 서비스인 경우, UDP를 사용하게 된다.
UDP는 중간에 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리해버린다.

실시간 화상회의가 아닌 넷플리스나 유튜브 같은 동영상 스트리밍이라면 TCP를 사용해도 된다. 원활한 시청을
위해 수 초~수 분의 동영상 데이터를 미리 받아놓고 네트워크에 잠시 문제가 발생하더라도 동영상이 끊기지
않도록 캐시에 저장하기 때문이다.

### ARP

OSI 7계층 중 2, 3계층이 주소를 가지고 있고 통신할 때 목적지를 찾아갈 수 있도록 하지만 사실 2계층
MAC 주소와 3계층 IP 주소 간에는 아무 관계도 없다. MAC 주소는 하드웨어 생산업체가 임의적으로
할당한 주소이고 NIC에 종속된 주소다. 3계층 IP 주소는 우리가 직접 할당하거나 DHCP를 이용해 자동으로 할당
받는다. 실제 통신은 IP 주소 기반으로 일어나고 MAC 주소는 상대방의 주소를 자동으로 알아내 통신하게 된다.
이때 상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜이 ARP(Address Resolution Protocol)이다.
ARP 프로토콜은 IP와 MAC 주소를 연계시켜 주기 위한 프로토콜이다.

ARP 프로토콜은 TCP-이더넷 프로토콜과 같이 3계층 논리적 주소와 2계층 물리적 주소 사이에 관계가 없는
프로토콜에서 ARP 프로토콜과 같은 메커니즘을 사용해 물리적 주소와 논리적 주소를 연결한다. 호스트에서
아무 통신이 없다가 처음 통신을 시도하면 패킷을 바로 캡슐화 할 수 없다. 출발지와 목적지 IP 주소는 미리 알고
있어 캡슐화하는데 문제가 없지만 상대방의 MAC 주소를 알 수 없어 2계층 캡슐화를 수행할 수 없다. 상대방의
MAC 주소를 알아내려면 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC 주소를 질의해야 한다.

ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜을 이용해 자신의 MAC 주소를 응답한다. 이 작업이 완료되면
출발지, 목적지 둘 다 상대방에 대한 MAC 주소를 학습하고 이후 패킷이 정상적으로 인캡슐레이션되어 상대방에게
전달될 수 있다.

패킷 네트워크에서는 큰 데이터를 잘라 전송하므로 여러 개의 패킷을 전송해야 한다. 패킷을 보낼 때마다 ARP
브로드캐스트를 수행하면 네트워크 통신의 효율성이 크게 저하되므로 메모리에 이 정보를 저장해두고 재사용한다.
성능 유지를 위해서는 ARP 테이블을 오래 유지하는 것이 좋지만 논리 주소는 언제든지 바뀔 수 있으므로 일정 시간
동안 통신이 없으면 이 테이블은 삭제된다.

네트워크 장비에서의 ARP 작업은 CPU에서 직접 수행하므로 짧은 시간에 많은 ARP 요청이 들어오면 네트워크
장비에서는 큰 부하로 작용한다.

ARP 패킷은 여러 가지 필드 중 ARP 데이터에 사용되는 송신자 하드웨어 MAC 주소, 송신자 IP, 대상자 MAC, IP
총 4개의 필드가 중요하게 사용된다. 처음에는 대상의 MAC 주소를 모르기 때문에 패킷의 목적지 MAC 주소를
브로드캐스트 주소인 FF-FF-FF-FF-FF-FF로 채우게 된다. 그리고 ARP 프로토콜 필드의 대상자 MAC 주소는
00-00-00-00-00-00으로 채워 네트워크에 뿌린다. 이렇게 모든 네트워크에 뿌리면 알맞은 대상이 자신의 MAC
주소를 채워서 응답할 수 있다. 따라서 ARP 요청을 처음 보낼 때는 브로드캐스트지만, ARP 응답은 유니캐스트다.
ARP 응답은 받은 서버는 자신의 ARP 캐시 테이블을 갱신한다.  캐시 테이블이 갱신된 후에는 상대방의 MAC 주소를
알고 있으므로 도착지 MAC 필드를 완성해 패킷을 보낼 수 있다.

### GARP

ARP 프로토콜을 원래 목적과 다른 용도로 사용하는 GARP, RARP 등의 프로토콜이 있다. Gratuitous ARP의 약자인
GARP는 대상자 IP 필드에 자신의 IP 주소를 채워 ARP 요청을 보낸다. GARP는 자신의 IP와 MAC 주소를 알릴 목적
으로 사용된다. 로컬 네트워크에 자신의 IP와 MAC 주소를 알릴 목적으로 사용되므로 GARP의 목적지 MAC 주소는
브로드캐스트 MAC 주소를 사용한다.
GARP를 사용해 IP, MAC 주소를 알리는 이유는 3가지다.

1. IP 주소 충돌 감지
2. 상대방의 ARP 테이블 갱신
3. HA(고가용성) 용도의 클러스터링, VRRP, HSRP

IP 주소 충돌 감지

> IP 주소는 유일하게 할당되어야 하는 값이지만 여러 가지 이유로 내가 할당받은 IP를 다른 사람이 사용하고 있을
수 있다. IP 충돌 때문에 통신이 안 되는 것을 예방하기 위해 자신에게 할당된 IP가 네트워크에서 이미 사용되고
있는지 GARP를 통해 확인한다. 단말이 네트워크에 연결되면 GARP를 통해 현재 설정된 IP 주소를 네트워크에서
사용하고 있는지 확인할 수 있다. 만약 응답이 오면 네트워크상에서 해당 IP를 이미 사용 중인 단말이 있다는 것을
알 수 있다.


상대방(동일 서브넷에 있는)의 ARP 테이블 갱신

> GARP의 두 번째 사용 목적은 동일 네트워크상 단말들의 ARP 테이블 갱신이다. 가상 MAC 주소를
사용하지 않는 데이터베이스 HA 솔루션에서 주로 사용한다. 데이터베이스 HA는 주로 두 데이터베이스 서버가
하나의 가상 IP 주소로 서비스한다. 두 대의 데이터베이스 중 한 대만 동작하고 나머지 한 대는 대기하는
액티브-스탠바이로 동작한다. 액티브 상태인 서버가 가상 IP 주소 요청에 응답해 서비스하지만 MAC 주소는
가상 주소가 아닌 실제 MAC 주소를 사용한다. 즉, 만약 마스터가 동작하지 않아 스탠바이가 활성화되면,
ARP 캐시 테이블에 있는 MAC 주소도 바뀐 DB서버의 MAC 주소로 변경되어야 DB가 정상적으로 동작할 것이다.
따라서 GARP를 통해 테이블 갱신을 한다. 최근에는 GARP를 이용해 패킷을 가로채는 기법이 많이 사용되어
보안상, 운영상의 이유로 GARP를 받더라도 테이블을 갱신하지 않는 단말이 있다. 이런 경우 가상 MAC 주소를 사용
하는 HA 솔루션을 사용한다.


클러스터링, FHRP(VRRP, HSRP)

> 가상 MAC을 사용하는 클러스터링, VRRP, HSRP와 같은 FHRP(First Hop Redundancy Protocol)에서도
GARP가 사용된다. 주로 네트워크에 있는 스위치 장비의 MAC 테이블 갱신이 목적이다.


VRRP, HSRP는 FHRP의 일종인데, 이 프로토콜들은 디폴트 게이트웨이에 장애가 발생할 경우, 해당 네트워크에
속한 단말이 외부 네트워크로 통신할 수 없는 문제를 해결하기 위해 개발되었다. 단독으로 경로 지정을 할 수
없는 PC는 디폴트 게이트웨이의 상태를 알 수 없으므로 두 대의 디폴트 게이트웨이 라우터가 한 대처럼 동작해
한 대에 문제가 생기더라도 다른 한 대에서 서비스를 지속할 수 있는 FHRP를 사용해야 한다.

클러스터링에서 가상 MAC 주소를 사용하는 경우, 단말은 ARP 정보를 가상 MAC 주소로 학습하므로 단말의
ARP 테이블을 갱신할 필요가 없다. 하지만 클러스터링 중간에 있는 스위치의 MAC 테이블은 마스터가 변경되었을
때 가상 MAC 주소의 위치를 적절히 찾아가도록 업데이트해야 하므로 마스터가 변경되는 시점에 MAC 테이블의
갱신이 필요하다. 따라서 슬레이브가 마스터로 역할이 변경되면 GARP를 전송하고 스위치에서는 이 GARP를 통해
MAC 주소에 대한 포트 정보를 새로 변경해 MAC 테이블을 갱신한다.

클러스터링이나 HA 솔루션에서 빠른 시간 안에 정상적으로 페일오버가 되지 않을 경우, 고가용성 솔루션 자체의
문제인 경우도 있지만 GARP를 받은 스위치가 MAC 테이블을 빨리 갱신해주지 않아 문제가 되는 경우도 많다.
HA 솔루션을 도입하는 경우, 사전에 이런 부분들이 반드시 함께 고려되고 테스트되어야 한다. 이 경우, HA 솔루션
에서 GARP를 보내는 시간이나 횟수를 조절하거나 스위치와 연결된 포트를 순간적으로 리셋(플랩)해 스위치의
MAC 테이블을 초기화시키는 기법을 사용하기도 한다.

### RARP

Reverse ARP의 줄임말이다. ARP 프로토콜 구조는 같지만 필드에 들어가는 내용이 다르고 원래 목적과 반대로 사용
된다. 즉, IP 주소가 정해져 있지 않은 단말이 IP 할당을 요청할 때 사용한다.
ARP는 내가 통신해야 할 상대방의 MAC 주소를 모를 때 상대방의 IP 주소로 MAC 주소를 물어볼 목적으로 만들
어진 프로토콜이다. RARP는 반대로 나 자신의 MAC 주소는 알지만 IP가 아직 할당되지 않아 IP를 할당해주는
서버에 어떤 IP 주소를 써야 하는지 물어볼 때 사용된다. 지금은 BOOTP와 DHCP로 대체되었다.

### 서브넷과 게이트웨이

이메일과 인터넷 기술의 발달로 작은 LAN 네트워크들이 하나의 큰 네트워크로 묶이면서 먼 거리에 있는 다른
LAN 간의 통신이 중요해졌다. 같은 네트워크 내에서의 통신과 원격지 네트워크 간의 통신은 동작 방식이나
필요한 네트워크 장비가 모두 다르다. 원격지 네트워크와의 통신에 사용하는 장비를 게이트웨이라고 부르고
3계층 장비(라우터와 L3 스위치)가 이 역할을 할 수 있다.

### 서브넷과 게이트웨이의 용도

로컬 네트워크에서는 ARP 브로드캐스트를 이용해 도착지 MAC 주소를 학습할 수 있고 이 MAC 주소를 이용해
직접 통신할 수 있지만 원격 네트워크 통신은 네트워크를 넘어 전달되지 못하는 브로드캐스트의 성질 때문에
네트워크 장비의 도움이 필요하다. 이 장비를 게이트웨이라고 하고 게이트웨이에 대한 정보를 PC나 네트워크
장비에 설정하는 항목이 '기본 게이트웨이'다.

LAN인지 WAN인지에 따라 통신 방식이 달라지므로 출발지에서는 먼저 목적지가 LAN인지 WAN인지 확인하는
작업이 필요하다. 이때 사용되는 것이 서브넷 마스크다. 이 서브넷 마스크로 연산을 한 결과값 주소가 LAN에
속해있으면 로컬 통신이고 아니면 원격지 통신이다.

즉, 동일 네트워크 간의 통신과 서로 다른 네트워크 간의 통신을 구분하기 위해 사용되는 것이 서브넷 마스크다.
로컬 통신은 단순한 ARP 요청으로 목적지를 찾아 통신할 수 있지만 원격지 통신은 ARP가 라우터를 넘어가지
못하는 브로드캐스트이므로 외부와 통신이 가능한 장비의 도움이 필요하다.

프록시 ARP

> 말 그대로 ARP를 대행해주는 기능이다. 원격지 통신은 기본 게이트웨이를 찾아 ARP 요청을 보내고 패킷을
기본 게이트웨이 쪽으로 보내야만 통신할 수 있다. 하지만 기본 게이트웨이에 프록시 ARP가 활성화된 경우,
원격지 통신이더라도 로컬에 ARP 브로드캐스트를 보내 통신할 수 있다. 프록시 ARP가 활성화된 기본 게이트웨이는
ARP 브로드캐스트가 들어오면 자신이 대행해 ARP 응답을 해준다. 이 경우, 패킷이 기본 게이트웨이 쪽으로
보내지므로 원격지 경로로 전달될 수 있다. 프록시 ARP 기능은 라우터에 기본으로 활성화되어 있어
사용자 몰래 동작하는 경우가 많다. 프록시 ARP는 사용자 설정 없이 자동으로 동작해 편리한 것처럼 느껴지지만
네트워크에 설정 오류가 있거나 꼭 입력해야 할 설정이 되어 있지 않아도 동작하는 경우가 많아 장애가 발생했을
때 쉽게 해결할 수 없게 만드는 장애 요소가 되기도 한다.
문제의 근본 원인이 PC에서 기본 게이트웨이를 잘못 설정한 것인데도 불구하고 라우터의 문제로 인식되어
근본적인 문제 해결에 방해가 될 수 있다.
 

2계층 통신 vs 3계층 통신

> 2계층 통신, 3계층 통신은 원래 정확한 표현은 아니지만 실무에서 많이 쓰는 표현이다. 정확한 표현은 로컬
네트워크 통신, 원격지 네트워크 통신이다. 단말 간의 통신은 애플리케이션 계층부터 시작해 캡슐화, 디캡슐화를
거쳐 통신하는데 로컬 네트워크에서 직접 통신할 경우, 라우터와 같은 3계층 네트워크 장비의 도움 없이
통신이 가능하다. 즉, 단말 간을 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을
보낼 때 직접 브로드캐스트를 이용하므로 이를 L2 통신이라고 부른다. 반면, 원격지 네트워크와 통신해야 할 경우,
라우터와 같은 3계층 장비의 도움이 없으면 통신할 수 없다. 해당 패킷을 전송하는 네트워크 장비에서 3계층
정보까지 확인해야 하며 이것을 L3 통신이라고 한다.


> 즉, 같은 네트워크끼리의 통신은 ARP 브로드캐스트를 이용해서 상대방의 MAC 주소를 알아내자마자 패킷이
캡슐화되어 통신이 시작된다. 반면 외부 네트워크와 통신이 필요할 때는 ARP 요청을 기본 게이트웨이의 IP주소로
요청한다. 게이트웨이에서 ARP 응답을 받은 단말은 도착지 MAC 주소에 응답받은 기본 게이트웨이의 MAC 주소를
적어넣고 통신을 시작한다.
로컬 통신은 도착지 MAC 주소와 도착지 IP 주소가 같은 반면, 원격지 통신은 다르다. 도착지 IP주소는 통신의 실제
도착지이고 도착지 MAC 주소는 디폴트 게이트웨이의 MAC 주소가 사용된다.
